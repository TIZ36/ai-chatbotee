---
description: Agent Actor 高并发处理架构与Topic会话优化方案
globs: 
  - "backend/services/agent_actor.py"
  - "front/src/components/Workflow.tsx"
  - "front/src/services/session/**"
alwaysApply: false
---

# Agent Actor 高并发处理架构

## 一、架构示意图

```
┌─────────────────────────────────────────────────────────────────────────────────┐
│                          Agent Actor 高并发处理架构                               │
└─────────────────────────────────────────────────────────────────────────────────┘

                              ┌──────────────────┐
                              │   User Requests  │
                              │  (并发消息流入)   │
                              └────────┬─────────┘
                                       │
           ┌───────────────────────────┼───────────────────────────┐
           │                           │                           │
           ▼                           ▼                           ▼
    ┌─────────────┐             ┌─────────────┐             ┌─────────────┐
    │  Message 1  │             │  Message 2  │             │  Message N  │
    └──────┬──────┘             └──────┬──────┘             └──────┬──────┘
           │                           │                           │
           └───────────────────────────┼───────────────────────────┘
                                       │
                                       ▼
┌─────────────────────────────────────────────────────────────────────────────────┐
│                              MAILBOX (消息队列)                                  │
│  ┌─────┐ ┌─────┐ ┌─────┐ ┌─────┐ ┌─────┐ ┌─────┐ ┌─────┐ ┌─────┐              │
│  │ M1  │→│ M2  │→│ M3  │→│ M4  │→│ M5  │→│ M6  │→│ M7  │→│ ... │  ──────────▶ │
│  └─────┘ └─────┘ └─────┘ └─────┘ └─────┘ └─────┘ └─────┘ └─────┘   FIFO       │
│                                                                                 │
│  特性: ✓ 非阻塞入队  ✓ 顺序处理  ✓ 引用回复支持  ✓ 背压控制                     │
└─────────────────────────────────────────────────────────────────────────────────┘
                                       │
                                       │ 逐条取出处理
                                       ▼
┌─────────────────────────────────────────────────────────────────────────────────┐
│                              AGENT ACTOR (单线程处理)                            │
│                                                                                 │
│  ┌───────────────────────────────────────────────────────────────────────────┐ │
│  │                        CapabilityChecker (能力检查器)                      │ │
│  │                                                                           │ │
│  │   ┌─────────────┐    ┌─────────────┐    ┌─────────────┐                  │ │
│  │   │   Persona   │    │    Tools    │    │  Workflows  │                  │ │
│  │   │  (人设配置)  │    │  (工具能力)  │    │ (工作流能力) │                  │ │
│  │   └──────┬──────┘    └──────┬──────┘    └──────┬──────┘                  │ │
│  │          └──────────────────┼──────────────────┘                          │ │
│  │                             ▼                                             │ │
│  │                    ┌─────────────────┐                                    │ │
│  │                    │   能力匹配判断   │                                    │ │
│  │                    └────────┬────────┘                                    │ │
│  │                             │                                             │ │
│  │              ┌──────────────┴──────────────┐                              │ │
│  │              ▼                              ▼                              │ │
│  │      ┌─────────────┐                ┌─────────────┐                       │ │
│  │      │  ✓ 有能力   │                │  ✗ 无能力   │                       │ │
│  │      └──────┬──────┘                └──────┬──────┘                       │ │
│  │             │                              │                              │ │
│  │             ▼                              ▼                              │ │
│  │      ┌─────────────┐                ┌─────────────┐                       │ │
│  │      │  执行处理   │                │ RejectPolicy│                       │ │
│  │      │  LLM调用    │                │  (拒绝策略)  │                       │ │
│  │      └──────┬──────┘                └──────┬──────┘                       │ │
│  │             │                              │                              │ │
│  │             │                    ┌─────────┴─────────┐                    │ │
│  │             │                    ▼                   ▼                    │ │
│  │             │             ┌───────────┐       ┌───────────┐               │ │
│  │             │             │  静默等待  │       │ 存储问题  │               │ │
│  │             │             │ (不回复)   │       │ 待学习    │               │ │
│  │             │             └───────────┘       └─────┬─────┘               │ │
│  │             │                                       │                     │ │
│  └─────────────┼───────────────────────────────────────┼─────────────────────┘ │
│                │                                       │                       │
│                ▼                                       ▼                       │
│  ┌─────────────────────────┐         ┌─────────────────────────────────────┐  │
│  │   KnowledgeAbsorber     │◀────────│   Learning Queue (学习队列)          │  │
│  │   (知识吸收器)           │         │   从其他Agent回答中学习              │  │
│  └─────────────────────────┘         └─────────────────────────────────────┘  │
│                │                                                               │
│                ▼                                                               │
│  ┌─────────────────────────────────────────────────────────────────────────┐  │
│  │                          Memory (长期记忆)                               │  │
│  │   ┌───────────┐  ┌───────────┐  ┌───────────┐  ┌───────────┐            │  │
│  │   │ 对话记忆  │  │ 知识图谱  │  │ 技能经验  │  │ 用户偏好  │            │  │
│  │   └───────────┘  └───────────┘  └───────────┘  └───────────┘            │  │
│  └─────────────────────────────────────────────────────────────────────────┘  │
│                                                                                │
└─────────────────────────────────────────────────────────────────────────────────┘
                                       │
                                       ▼
┌─────────────────────────────────────────────────────────────────────────────────┐
│                              Response Dispatch (响应分发)                        │
│                                                                                 │
│       ┌─────────────┐       ┌─────────────┐       ┌─────────────┐              │
│       │  Streaming  │       │   Batch     │       │  Callback   │              │
│       │  (流式输出)  │       │ (批量返回)  │       │  (回调通知)  │              │
│       └─────────────┘       └─────────────┘       └─────────────┘              │
│                                                                                 │
└─────────────────────────────────────────────────────────────────────────────────┘
```

## 二、多Agent协作场景

```
┌─────────────────────────────────────────────────────────────────────────────────┐
│                              多Agent协作场景 (Topic/RoundTable)                  │
└─────────────────────────────────────────────────────────────────────────────────┘

  ┌─────────────┐      ┌─────────────┐      ┌─────────────┐      ┌─────────────┐
  │   Agent A   │      │   Agent B   │      │   Agent C   │      │   Agent N   │
  │  ┌───────┐  │      │  ┌───────┐  │      │  ┌───────┐  │      │  ┌───────┐  │
  │  │Mailbox│  │      │  │Mailbox│  │      │  │Mailbox│  │      │  │Mailbox│  │
  │  └───┬───┘  │      │  └───┬───┘  │      │  └───┬───┘  │      │  └───┬───┘  │
  │      │      │      │      │      │      │      │      │      │      │      │
  │  ┌───▼───┐  │      │  ┌───▼───┐  │      │  ┌───▼───┐  │      │  ┌───▼───┐  │
  │  │ Actor │  │◀────▶│  │ Actor │  │◀────▶│  │ Actor │  │◀────▶│  │ Actor │  │
  │  └───────┘  │      │  └───────┘  │      │  └───────┘  │      │  └───────┘  │
  └─────────────┘      └─────────────┘      └─────────────┘      └─────────────┘
         │                    │                    │                    │
         │                    │                    │                    │
         └────────────────────┴────────────────────┴────────────────────┘
                                       │
                                       ▼
                         ┌─────────────────────────┐
                         │   Redis Pub/Sub         │
                         │   (消息中转/广播)        │
                         │                         │
                         │  ┌───┐ ┌───┐ ┌───┐     │
                         │  │ Q │ │ Q │ │ Q │ ... │
                         │  └───┘ └───┘ └───┘     │
                         └─────────────────────────┘
```

## 三、并发处理时序图

```
  时间 ─────────────────────────────────────────────────────────────────────────▶

  User1  ──▶ [Msg1] ────────────────────────────────────────────────▶ [Reply1]
  User2  ────────▶ [Msg2] ──────────────────────────────────▶ [Reply2]
  User3  ──────────────▶ [Msg3] ────────────────────▶ [Reply3]
  User4  ────────────────────▶ [Msg4] ──────▶ [Reply4]

           ║              ║              ║              ║
           ▼              ▼              ▼              ▼
  ┌─────────────────────────────────────────────────────────────────────────────┐
  │ Mailbox: [M1]──▶[M2]──▶[M3]──▶[M4]                                          │
  └─────────────────────────────────────────────────────────────────────────────┘
           │
           ▼
  ┌─────────────────────────────────────────────────────────────────────────────┐
  │ Actor:  ┌────┐    ┌────┐    ┌────┐    ┌────┐                                │
  │         │ M1 │───▶│ M2 │───▶│ M3 │───▶│ M4 │  (顺序处理，保证状态一致性)     │
  │         └────┘    └────┘    └────┘    └────┘                                │
  └─────────────────────────────────────────────────────────────────────────────┘

  关键特性:
  ┌─────────────────────────────────────────────────────────────────────────────┐
  │ ✓ 无锁并发: 消息入队无需加锁，Actor单线程处理无竞争                           │
  │ ✓ 状态隔离: 每个Actor独立状态，无共享可变状态                                 │
  │ ✓ 异步非阻塞: LLM调用异步，不阻塞主线程                                       │
  │ ✓ 背压控制: Mailbox满时可拒绝或缓冲新消息                                     │
  │ ✓ 故障隔离: 单个Actor崩溃不影响其他Actor                                      │
  └─────────────────────────────────────────────────────────────────────────────┘
```

---

# Topic会话优化方案

## 问题一：响应提示不及时

### 现状分析

当前流程中，Agent 在判断是否响应时（`_decide_action` + `_llm_intent_decision`），前端没有任何提示：

```
用户发送消息 → Agent收到 → [决策中...无提示] → 开始生成(才有提示) → 流式输出
                                    ↑
                            用户不知道Agent在干什么
```

### 解决方案

添加完整的 Agent 状态生命周期事件：

```
┌─────────────────────────────────────────────────────────────────────────────────┐
│                          Agent 响应状态生命周期                                   │
└─────────────────────────────────────────────────────────────────────────────────┘

  用户消息 ──▶ agent_received ──▶ agent_deciding ──▶ agent_decision_made
                   │                    │                    │
                   ▼                    ▼                    ▼
              "收到消息"          "正在思考..."         决策结果
                                                            │
                   ┌────────────────────────────────────────┼────────────────┐
                   │                    │                   │                │
                   ▼                    ▼                   ▼                ▼
              [reply]              [silent]            [like]          [delegate]
                   │                    │                   │                │
                   ▼                    ▼                   ▼                ▼
          agent_thinking          (无后续)           (点赞动画)      @转发消息
                   │
                   ▼
          agent_stream_chunk ──▶ agent_stream_done
```

### 后端改动 (agent_actor.py)

```python
def _handle_new_message(self, topic_id: str, msg_data: dict):
    """处理新消息并决定是否回答"""
    sender_id = msg_data.get('sender_id')
    message_id = msg_data.get('message_id')
    
    # 1. 过滤掉自己的消息
    if sender_id == self.agent_id:
        return

    # ✅ 新增：通知前端 - Agent 已收到消息
    get_topic_service()._publish_event(topic_id, 'agent_received', {
        'agent_id': self.agent_id,
        'agent_name': self.info.get('name', 'Agent'),
        'agent_avatar': self.info.get('avatar'),  # 新增头像
        'message_id': message_id,
        'timestamp': time.time()
    })

    # ✅ 新增：通知前端 - Agent 正在决策
    get_topic_service()._publish_event(topic_id, 'agent_deciding', {
        'agent_id': self.agent_id,
        'agent_name': self.info.get('name', 'Agent'),
        'agent_avatar': self.info.get('avatar'),
        'message_id': message_id,
        'status': 'thinking',  # thinking | decided
        'timestamp': time.time()
    })

    # 2. 会话收敛：判断行为
    action = self._decide_action(topic_id, msg_data)

    # ✅ 新增：通知前端 - 决策完成
    get_topic_service()._publish_event(topic_id, 'agent_decision_made', {
        'agent_id': self.agent_id,
        'agent_name': self.info.get('name', 'Agent'),
        'agent_avatar': self.info.get('avatar'),
        'message_id': message_id,
        'decision': action,  # reply | silent | like | oppose | delegate:xxx
        'timestamp': time.time()
    })

    if action == 'silent':
        return
    
    # ... 后续处理
```

### 前端改动 (Workflow.tsx)

```tsx
// 新增状态
const [decidingAgents, setDecidingAgents] = useState<Map<string, {
  agentId: string;
  agentName: string;
  agentAvatar?: string;
  messageId: string;
  status: 'received' | 'thinking' | 'decided';
  decision?: string;
}>>(new Map());

// SSE 事件处理
} else if (payload.type === 'agent_received') {
  const data = payload.data;
  setDecidingAgents(prev => {
    const next = new Map(prev);
    next.set(data.agent_id, {
      agentId: data.agent_id,
      agentName: data.agent_name,
      agentAvatar: data.agent_avatar,
      messageId: data.message_id,
      status: 'received'
    });
    return next;
  });
  
} else if (payload.type === 'agent_deciding') {
  const data = payload.data;
  setDecidingAgents(prev => {
    const next = new Map(prev);
    const existing = next.get(data.agent_id);
    next.set(data.agent_id, {
      ...existing,
      agentId: data.agent_id,
      agentName: data.agent_name,
      agentAvatar: data.agent_avatar,
      messageId: data.message_id,
      status: 'thinking'
    });
    return next;
  });
  
} else if (payload.type === 'agent_decision_made') {
  const data = payload.data;
  if (data.decision === 'silent') {
    // 静默：移除决策状态，添加淡出动画
    setDecidingAgents(prev => {
      const next = new Map(prev);
      next.delete(data.agent_id);
      return next;
    });
  } else if (data.decision === 'reply') {
    // 回复：保持状态，等待 agent_thinking 事件
    setDecidingAgents(prev => {
      const next = new Map(prev);
      const existing = next.get(data.agent_id);
      next.set(data.agent_id, {
        ...existing,
        status: 'decided',
        decision: 'reply'
      });
      return next;
    });
  }
}
```

### UI 展示组件

```tsx
// 决策状态指示器
const AgentDecidingIndicator: React.FC<{
  agents: Map<string, DecidingAgentInfo>;
  participants: TopicParticipant[];
}> = ({ agents, participants }) => {
  if (agents.size === 0) return null;
  
  return (
    <div className="flex flex-wrap gap-2 px-4 py-2 text-xs text-gray-500">
      {Array.from(agents.values()).map(agent => (
        <div 
          key={agent.agentId}
          className="flex items-center gap-1.5 animate-pulse"
        >
          <MessageAvatar 
            role="assistant" 
            avatarUrl={agent.agentAvatar} 
            size="sm" 
          />
          <span>
            {agent.agentName}
            {agent.status === 'received' && ' 收到消息...'}
            {agent.status === 'thinking' && ' 正在思考是否回答...'}
            {agent.status === 'decided' && agent.decision === 'reply' && ' 准备回答...'}
          </span>
        </div>
      ))}
    </div>
  );
};
```

---

## 问题二：Topic会话记忆与头像昵称显示

### 现状分析

```
问题1: 消息存储时没有保存完整的发送者信息
问题2: 前端需要通过 topicParticipants 查找，但参与者列表可能不同步
问题3: 历史消息加载时，需要额外查询发送者信息
```

### 解决方案

#### 消息结构扩展

```python
# 消息存储结构（后端）
{
    "message_id": "msg_xxx",
    "session_id": "topic_xxx",  # topic session ID
    "role": "assistant",
    "content": "...",
    
    # ✅ 新增：发送者完整信息（冗余存储，避免查询）
    "sender": {
        "id": "agent_xxx",
        "type": "agent",  # user | agent | system
        "name": "研究助手",
        "avatar": "https://..."
    },
    
    # 引用回复
    "reply_to": {
        "message_id": "msg_yyy",
        "sender_name": "用户",
        "content_preview": "请帮我..."  # 前50字
    },
    
    # 时间戳
    "created_at": "2024-01-01T12:00:00Z"
}
```

#### 后端改动 (topic_service.py)

```python
def send_message(self, topic_id: str, sender_id: str, sender_type: str, 
                 content: str, role: str, message_id: str = None, **kwargs):
    """发送消息到 Topic"""
    
    # 获取发送者信息
    sender_info = self._get_sender_info(sender_id, sender_type)
    
    message_data = {
        'message_id': message_id or f"msg_{uuid.uuid4().hex[:8]}",
        'session_id': topic_id,
        'role': role,
        'content': content,
        'sender': {
            'id': sender_id,
            'type': sender_type,
            'name': sender_info.get('name', sender_id),
            'avatar': sender_info.get('avatar')
        },
        'created_at': datetime.utcnow().isoformat()
    }
    
    # 处理引用回复
    if kwargs.get('reply_to_message_id'):
        original = self._get_message(kwargs['reply_to_message_id'])
        if original:
            message_data['reply_to'] = {
                'message_id': original['message_id'],
                'sender_name': original.get('sender', {}).get('name', ''),
                'content_preview': original['content'][:50]
            }
    
    # 保存到数据库
    get_message_service().save_message(message_data)
    
    # 广播事件
    self._publish_event(topic_id, 'new_message', message_data)
```

#### 前端消息渲染

```tsx
// 消息类型定义
interface TopicMessage {
  id: string;
  role: 'user' | 'assistant' | 'system' | 'tool';
  content: string;
  sender: {
    id: string;
    type: 'user' | 'agent' | 'system';
    name: string;
    avatar?: string;
  };
  replyTo?: {
    messageId: string;
    senderName: string;
    contentPreview: string;
  };
  createdAt: string;
}

// 渲染消息
const renderTopicMessage = (message: TopicMessage) => {
  const isUser = message.sender.type === 'user';
  
  return (
    <div className={`flex ${isUser ? 'justify-end' : 'justify-start'}`}>
      {!isUser && (
        <div className="flex items-center gap-2 mb-1">
          <MessageAvatar 
            role="assistant" 
            avatarUrl={message.sender.avatar}  // ✅ 直接使用消息中的头像
            size="sm" 
          />
          <span className="text-xs text-gray-500">
            {message.sender.name}  {/* ✅ 直接使用消息中的昵称 */}
          </span>
        </div>
      )}
      
      {/* 引用回复 */}
      {message.replyTo && (
        <div className="text-xs text-gray-400 mb-1 pl-2 border-l-2 border-gray-300">
          回复 {message.replyTo.senderName}: {message.replyTo.contentPreview}
        </div>
      )}
      
      <MessageBubble role={isUser ? 'user' : 'assistant'}>
        <MessageRenderer content={message.content} />
      </MessageBubble>
    </div>
  );
};
```

---

## 问题三：Topic会话存储 - MCP/工作流/Skills调用过程

### 需求分析

```
用户完成一个任务后，需要：
1. 保存完整的调用过程（MCP调用、工作流执行、LLM交互）
2. 可以总结为 Skill 技能包
3. 下次 @技能包Agent 可以重放这个过程
```

### 执行轨迹结构设计

```python
# 消息扩展：execution_trace 字段
{
    "message_id": "msg_xxx",
    "role": "assistant",
    "content": "...",
    "sender": {...},
    
    # ✅ 新增：执行轨迹（完整记录调用过程）
    "execution_trace": {
        "trace_id": "trace_xxx",
        "started_at": "2024-01-01T12:00:00Z",
        "completed_at": "2024-01-01T12:00:30Z",
        "status": "success",  # success | error | cancelled
        
        # 步骤列表
        "steps": [
            {
                "step_id": "step_1",
                "type": "llm_call",
                "started_at": "...",
                "completed_at": "...",
                "input": {
                    "messages": [...],
                    "model": "gpt-4"
                },
                "output": {
                    "content": "...",
                    "tokens": 150
                }
            },
            {
                "step_id": "step_2", 
                "type": "mcp_call",
                "server_id": "mcp_filesystem",
                "tool_name": "read_file",
                "started_at": "...",
                "completed_at": "...",
                "input": {
                    "path": "/path/to/file"
                },
                "output": {
                    "content": "file content..."
                }
            },
            {
                "step_id": "step_3",
                "type": "workflow_execution",
                "workflow_id": "wf_xxx",
                "workflow_name": "数据分析流程",
                "started_at": "...",
                "completed_at": "...",
                "nodes_executed": [
                    {"node_id": "n1", "type": "input", "output": {...}},
                    {"node_id": "n2", "type": "llm", "output": {...}},
                    {"node_id": "n3", "type": "output", "output": {...}}
                ]
            }
        ],
        
        # 总结（用于生成 Skill）
        "summary": {
            "description": "读取文件并分析数据",
            "tools_used": ["mcp:filesystem", "workflow:data_analysis"],
            "key_params": ["file_path", "analysis_type"],
            "replayable": true
        }
    }
}
```

### Skill 技能包结构

```python
# Skill 定义
{
    "skill_id": "skill_xxx",
    "name": "数据分析助手",
    "description": "从文件读取数据并进行分析",
    "created_from": {
        "topic_id": "topic_xxx",
        "message_ids": ["msg_1", "msg_2", "msg_3"],
        "trace_ids": ["trace_xxx"]
    },
    
    # 模板化的执行步骤
    "template": {
        "steps": [
            {
                "type": "mcp_call",
                "server_id": "mcp_filesystem",
                "tool_name": "read_file",
                "params": {
                    "path": "{{file_path}}"  # 参数化
                }
            },
            {
                "type": "llm_call",
                "system_prompt": "你是一个数据分析助手...",
                "user_prompt": "分析以下数据：{{data}}"
            }
        ],
        
        # 输入参数定义
        "input_params": [
            {"name": "file_path", "type": "string", "required": true},
            {"name": "analysis_type", "type": "enum", "options": ["summary", "detail"]}
        ]
    },
    
    # 绑定的 Agent
    "agent_id": "agent_skill_xxx"  # 创建专门的 Skill Agent
}
```

### 后端实现 (agent_actor.py)

```python
class AgentActor:
    def _generate_streaming_reply_with_trace(self, topic_id: str, user_content: str, 
                                              used_tools: List[str], in_reply_to: str = None):
        """流式产生回复并记录完整执行轨迹"""
        
        # 初始化执行轨迹
        trace = ExecutionTrace(
            trace_id=f"trace_{uuid.uuid4().hex[:8]}",
            agent_id=self.agent_id
        )
        trace.start()
        
        try:
            # Step 1: MCP 调用
            for tool in used_tools:
                if tool.startswith('mcp:'):
                    server_id = tool.split(':')[1]
                    step = trace.start_step('mcp_call', server_id=server_id)
                    try:
                        result = self._call_mcp_tool(server_id, user_content)
                        step.complete(output=result)
                    except Exception as e:
                        step.fail(error=str(e))
                        
            # Step 2: Workflow 执行
            for tool in used_tools:
                if tool.startswith('workflow:'):
                    workflow_id = tool.split(':')[1]
                    step = trace.start_step('workflow_execution', workflow_id=workflow_id)
                    try:
                        result = self._execute_workflow(workflow_id, user_content)
                        step.complete(output=result, nodes_executed=result.get('nodes'))
                    except Exception as e:
                        step.fail(error=str(e))
            
            # Step 3: LLM 调用
            step = trace.start_step('llm_call')
            # ... 流式 LLM 调用
            step.complete(output={'content': full_content, 'tokens': token_count})
            
            trace.complete()
            
            # 保存消息时包含执行轨迹
            get_topic_service().send_message(
                topic_id=topic_id,
                sender_id=self.agent_id,
                sender_type='agent',
                content=full_content,
                role='assistant',
                message_id=reply_message_id,
                execution_trace=trace.to_dict()  # ✅ 保存执行轨迹
            )
            
        except Exception as e:
            trace.fail(error=str(e))
            raise


class ExecutionTrace:
    """执行轨迹记录器"""
    
    def __init__(self, trace_id: str, agent_id: str):
        self.trace_id = trace_id
        self.agent_id = agent_id
        self.steps = []
        self.started_at = None
        self.completed_at = None
        self.status = 'pending'
    
    def start(self):
        self.started_at = datetime.utcnow().isoformat()
        self.status = 'running'
    
    def start_step(self, step_type: str, **kwargs) -> 'TraceStep':
        step = TraceStep(
            step_id=f"step_{len(self.steps) + 1}",
            type=step_type,
            **kwargs
        )
        step.start()
        self.steps.append(step)
        return step
    
    def complete(self):
        self.completed_at = datetime.utcnow().isoformat()
        self.status = 'success'
    
    def fail(self, error: str):
        self.completed_at = datetime.utcnow().isoformat()
        self.status = 'error'
        self.error = error
    
    def to_dict(self) -> dict:
        return {
            'trace_id': self.trace_id,
            'agent_id': self.agent_id,
            'started_at': self.started_at,
            'completed_at': self.completed_at,
            'status': self.status,
            'steps': [s.to_dict() for s in self.steps],
            'summary': self._generate_summary()
        }
    
    def _generate_summary(self) -> dict:
        tools_used = []
        for step in self.steps:
            if step.type == 'mcp_call':
                tools_used.append(f"mcp:{step.server_id}")
            elif step.type == 'workflow_execution':
                tools_used.append(f"workflow:{step.workflow_id}")
        
        return {
            'tools_used': tools_used,
            'steps_count': len(self.steps),
            'replayable': all(s.status == 'success' for s in self.steps)
        }
```

### 前端：保存为 Skill

```tsx
// 总结为 Skill 对话框
const SaveAsSkillDialog: React.FC<{
  open: boolean;
  onOpenChange: (open: boolean) => void;
  messages: TopicMessage[];
  onSave: (skill: SkillDefinition) => void;
}> = ({ open, onOpenChange, messages, onSave }) => {
  const [skillName, setSkillName] = useState('');
  const [description, setDescription] = useState('');
  
  // 从消息中提取执行轨迹
  const traces = useMemo(() => {
    return messages
      .filter(m => m.execution_trace)
      .map(m => m.execution_trace);
  }, [messages]);
  
  const handleSave = async () => {
    const skill = await createSkillFromTraces({
      name: skillName,
      description,
      traces,
      source: {
        topic_id: currentTopicId,
        message_ids: messages.map(m => m.id)
      }
    });
    onSave(skill);
    onOpenChange(false);
  };
  
  return (
    <Dialog open={open} onOpenChange={onOpenChange}>
      <DialogContent>
        <DialogHeader>
          <DialogTitle>保存为技能包</DialogTitle>
          <DialogDescription>
            将本次对话过程保存为可重放的技能包
          </DialogDescription>
        </DialogHeader>
        
        <div className="space-y-4">
          <InputField
            label="技能名称"
            required
            inputProps={{
              value: skillName,
              onChange: e => setSkillName(e.target.value),
              placeholder: "例如：数据分析助手"
            }}
          />
          
          <TextareaField
            label="技能描述"
            textareaProps={{
              value: description,
              onChange: e => setDescription(e.target.value),
              placeholder: "描述这个技能的用途..."
            }}
          />
          
          {/* 执行轨迹预览 */}
          <div className="border rounded-md p-3">
            <h4 className="text-sm font-medium mb-2">包含的操作步骤</h4>
            {traces.map(trace => (
              <div key={trace.trace_id} className="text-xs text-gray-500">
                {trace.steps.map(step => (
                  <div key={step.step_id} className="flex items-center gap-2">
                    <Badge variant={step.status === 'success' ? 'success' : 'error'}>
                      {step.type}
                    </Badge>
                    <span>{step.tool_name || step.workflow_name || 'LLM调用'}</span>
                  </div>
                ))}
              </div>
            ))}
          </div>
        </div>
        
        <DialogFooter>
          <Button variant="secondary" onClick={() => onOpenChange(false)}>
            取消
          </Button>
          <Button variant="primary" onClick={handleSave}>
            保存技能
          </Button>
        </DialogFooter>
      </DialogContent>
    </Dialog>
  );
};
```

---

## 实施优先级

| 优先级 | 功能 | 影响 | 工作量 |
|-------|------|------|-------|
| P0 | Agent决策状态提示 | 用户体验 | 2天 |
| P0 | 消息sender信息完善 | 头像昵称显示 | 1天 |
| P1 | 执行轨迹记录 | Skill基础 | 3天 |
| P1 | MCP实际调用实现 | 功能完整性 | 3天 |
| P2 | Skill保存与管理 | 高级功能 | 5天 |
| P2 | Skill重放执行 | 高级功能 | 5天 |

## 数据库变更

```sql
-- 消息表扩展
ALTER TABLE messages ADD COLUMN sender_info JSON;
ALTER TABLE messages ADD COLUMN execution_trace JSON;
ALTER TABLE messages ADD COLUMN reply_to JSON;

-- 新增技能表
CREATE TABLE skills (
    skill_id VARCHAR(64) PRIMARY KEY,
    name VARCHAR(255) NOT NULL,
    description TEXT,
    template JSON NOT NULL,
    source JSON,  -- 来源：topic_id, message_ids
    agent_id VARCHAR(64),  -- 绑定的Agent
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
);
```
