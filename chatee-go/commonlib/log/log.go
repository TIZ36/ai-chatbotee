package log
package log

import (
	"context"
	"os"
































































































































































































































































































}	return globalLogger.WithContext(ctx)func L(ctx context.Context) Logger {// L returns a logger with context.}	globalLogger.Warn(msg, fields...)func Warn(msg string, fields ...Field) {// Warn logs a warning message using the global logger.}	globalLogger.Info(msg, fields...)func Info(msg string, fields ...Field) {// Info logs an info message using the global logger.}	globalLogger.Debug(msg, fields...)func Debug(msg string, fields ...Field) {// Debug logs a debug message using the global logger.}	globalLogger = loggerfunc SetDefault(logger Logger) {// SetDefault sets the global logger.}	return globalLoggerfunc Default() Logger {// Default returns the global logger.}	return nil	globalLogger = logger	}		return err	if err != nil {	logger, err := NewLogger(config)func Init(config LogConfig) error {// Init initializes the global logger.var globalLogger Logger = &ZapLogger{logger: zap.NewNop()}// =============================================================================// Global Logger// =============================================================================}	return fields	}		}			fields = append(fields, String("span_id", s))		if s, ok := v.(string); ok && s != "" {	if v := ctx.Value(SpanIDKey); v != nil {	}		}			fields = append(fields, String("trace_id", s))		if s, ok := v.(string); ok && s != "" {	if v := ctx.Value(TraceIDKey); v != nil {	}		}			fields = append(fields, String("session_id", s))		if s, ok := v.(string); ok && s != "" {	if v := ctx.Value(SessionIDKey); v != nil {	}		}			fields = append(fields, String("user_id", s))		if s, ok := v.(string); ok && s != "" {	if v := ctx.Value(UserIDKey); v != nil {	}		}			fields = append(fields, String("request_id", s))		if s, ok := v.(string); ok && s != "" {	if v := ctx.Value(RequestIDKey); v != nil {	var fields []Fieldfunc extractContextFields(ctx context.Context) []Field {// extractContextFields extracts logging fields from context.}	return context.WithValue(ctx, TraceIDKey, id)func WithTraceID(ctx context.Context, id string) context.Context {// WithTraceID adds trace ID to context.}	return context.WithValue(ctx, SessionIDKey, id)func WithSessionID(ctx context.Context, id string) context.Context {// WithSessionID adds session ID to context.}	return context.WithValue(ctx, UserIDKey, id)func WithUserID(ctx context.Context, id string) context.Context {// WithUserID adds user ID to context.}	return context.WithValue(ctx, RequestIDKey, id)func WithRequestID(ctx context.Context, id string) context.Context {// WithRequestID adds request ID to context.)	SpanIDKey    contextKey = "span_id"	TraceIDKey   contextKey = "trace_id"	SessionIDKey contextKey = "session_id"	UserIDKey    contextKey = "user_id"	RequestIDKey contextKey = "request_id"const (type contextKey string// =============================================================================// Context Keys// =============================================================================}	return l.logger.Sync()func (l *ZapLogger) Sync() error {// Sync flushes any buffered log entries.}	return l.With(fields...)	}		return l	if len(fields) == 0 {	fields := extractContextFields(ctx)func (l *ZapLogger) WithContext(ctx context.Context) Logger {// WithContext returns a logger with context fields.}	}		logger: l.logger.With(fields...),	return &ZapLogger{func (l *ZapLogger) With(fields ...Field) Logger {// With returns a logger with the given fields.}	l.logger.Fatal(msg, fields...)func (l *ZapLogger) Fatal(msg string, fields ...Field) {// Fatal logs a fatal message and exits.}	l.logger.Error(msg, fields...)func (l *ZapLogger) Error(msg string, fields ...Field) {// Error logs an error message.}	l.logger.Warn(msg, fields...)func (l *ZapLogger) Warn(msg string, fields ...Field) {// Warn logs a warning message.}	l.logger.Info(msg, fields...)func (l *ZapLogger) Info(msg string, fields ...Field) {// Info logs an info message.}	l.logger.Debug(msg, fields...)func (l *ZapLogger) Debug(msg string, fields ...Field) {// Debug logs a debug message.}	}, nil		sugar:  logger.Sugar(),		logger: logger,	return &ZapLogger{	logger := zap.New(core, opts...)	}		opts = append(opts, zap.AddCaller(), zap.AddCallerSkip(1))	if config.AddCaller {	opts := []zap.Option{}	// Create logger	core := zapcore.NewCore(encoder, output, level)	// Create core	}		output = zapcore.AddSync(file)		}			return nil, err		if err != nil {		file, err := os.OpenFile(config.OutputPath, os.O_APPEND|os.O_CREATE|os.O_WRONLY, 0644)	default:		output = zapcore.AddSync(os.Stderr)	case "stderr":		output = zapcore.AddSync(os.Stdout)	case "", "stdout":	switch config.OutputPath {	var output zapcore.WriteSyncer	// Create output	}		encoder = zapcore.NewJSONEncoder(encoderConfig)	} else {		encoder = zapcore.NewConsoleEncoder(encoderConfig)	if config.Format == "console" {	var encoder zapcore.Encoder	// Create encoder	}		EncodeCaller:   zapcore.ShortCallerEncoder,		EncodeDuration: zapcore.MillisDurationEncoder,		EncodeTime:     zapcore.ISO8601TimeEncoder,		EncodeLevel:    zapcore.LowercaseLevelEncoder,		LineEnding:     zapcore.DefaultLineEnding,		StacktraceKey:  "stacktrace",		MessageKey:     "msg",		FunctionKey:    zapcore.OmitKey,		CallerKey:      "caller",		NameKey:        "logger",		LevelKey:       "level",		TimeKey:        "time",	encoderConfig := zapcore.EncoderConfig{	// Create encoder config	}		level = zapcore.ErrorLevel	case "error":		level = zapcore.WarnLevel	case "warn":		level = zapcore.InfoLevel	case "info":		level = zapcore.DebugLevel	case "debug":	switch config.Level {	level := zapcore.InfoLevel	// Parse log levelfunc NewLogger(config LogConfig) (*ZapLogger, error) {// NewLogger creates a new logger.}	AddCaller  bool   `json:"add_caller"`	OutputPath string `json:"output_path"` // file path or "stdout"/"stderr"	Format     string `json:"format"`      // json, console	Level      string `json:"level"`       // debug, info, warn, errortype LogConfig struct {// LogConfig configures the logger.}	sugar  *zap.SugaredLogger	logger *zap.Loggertype ZapLogger struct {// ZapLogger wraps zap.Logger.// =============================================================================// ZapLogger Implementation// =============================================================================)	Time     = zap.Time	Duration = zap.Duration	Any      = zap.Any	Error    = zap.Error	Bool     = zap.Bool	Float64  = zap.Float64	Int64    = zap.Int64	Int      = zap.Int	String   = zap.Stringvar (// Common field constructors (re-exported from zap)type Field = zap.Field// Field is a logging field.}	WithContext(ctx context.Context) Logger	With(fields ...Field) Logger	Fatal(msg string, fields ...Field)	Error(msg string, fields ...Field)	Warn(msg string, fields ...Field)	Info(msg string, fields ...Field)	Debug(msg string, fields ...Field)type Logger interface {// Logger is the logging interface.// =============================================================================// Logger Interface// =============================================================================)	"go.uber.org/zap/zapcore"	"go.uber.org/zap"