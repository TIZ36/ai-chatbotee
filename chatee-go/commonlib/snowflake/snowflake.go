package snowflake
package snowflake

import (
	"fmt"
	"sync"
	"time"
)

// =============================================================================
// Snowflake ID Generator














































































































































































































































































}	return globalTypedGen.Generate(IDTypeChannel)	}		InitTyped(0)	if globalTypedGen == nil {func NewChannelID() string {// NewChannelID generates a new channel ID.}	return globalTypedGen.Generate(IDTypeChat)	}		InitTyped(0)	if globalTypedGen == nil {func NewChatID() string {// NewChatID generates a new chat ID.}	return globalTypedGen.Generate(IDTypeThread)	}		InitTyped(0)	if globalTypedGen == nil {func NewThreadID() string {// NewThreadID generates a new thread ID.}	return globalTypedGen.Generate(IDTypeMessage)	}		InitTyped(0)	if globalTypedGen == nil {func NewMessageID() string {// NewMessageID generates a new message ID.}	return globalTypedGen.Generate(IDTypeSession)	}		InitTyped(0)	if globalTypedGen == nil {func NewSessionID() string {// NewSessionID generates a new session ID.}	return globalTypedGen.Generate(IDTypeAgent)	}		InitTyped(0)	if globalTypedGen == nil {func NewAgentID() string {// NewAgentID generates a new agent ID.}	return globalTypedGen.Generate(IDTypeUser)	}		InitTyped(0)	if globalTypedGen == nil {func NewUserID() string {// NewUserID generates a new user ID.}	return initErr	})		globalTypedGen = gen		}			return			initErr = err		if err != nil {		gen, err := NewTypedID(nodeID)	globalTypedOnce.Do(func() {	var initErr errorfunc InitTyped(nodeID int64) error {// InitTyped initializes the global typed generator.)	globalTypedOnce sync.Once	globalTypedGen *TypedIDvar (// =============================================================================// Global Typed Generator// =============================================================================}	}		return "id"	default:		return "chn"	case IDTypeChannel:		return "cht"	case IDTypeChat:		return "thd"	case IDTypeThread:		return "msg"	case IDTypeMessage:		return "ses"	case IDTypeSession:		return "agt"	case IDTypeAgent:		return "usr"	case IDTypeUser:	switch t {func typePrefix(t IDType) string {// typePrefix returns the prefix for an ID type.}	return fmt.Sprintf("%s_%d", prefix, id)	prefix := typePrefix(idType)	id := t.sf.Generate()func (t *TypedID) Generate(idType IDType) string {// Generate generates a typed ID.}	return &TypedID{sf: sf}, nil	}		return nil, err	if err != nil {	sf, err := New(nodeID)func NewTypedID(nodeID int64) (*TypedID, error) {// NewTypedID creates a typed ID generator.}	sf *Snowflaketype TypedID struct {// TypedID generates an ID with type prefix.)	IDTypeChannel IDType = 7	IDTypeChat    IDType = 6	IDTypeThread  IDType = 5	IDTypeMessage IDType = 4	IDTypeSession IDType = 3	IDTypeAgent   IDType = 2	IDTypeUser    IDType = 1const (type IDType byte// IDType represents the type of entity.// =============================================================================// ID Types for different entities// =============================================================================}	return fmt.Sprintf("%d", Generate())func GenerateString() string {// GenerateString generates an ID string using the global generator.}	return globalGenerator.Generate()	}		Init(0)		// Auto-initialize with node 0 if not initialized	if globalGenerator == nil {func Generate() int64 {// Generate generates an ID using the global generator.}	return initErr	})		globalGenerator = gen		}			return			initErr = err		if err != nil {		gen, err := New(nodeID)	globalOnce.Do(func() {	var initErr errorfunc Init(nodeID int64) error {// Init initializes the global generator with the given node ID.)	globalOnce      sync.Once	globalGenerator *Snowflakevar (// =============================================================================// Global Generator// =============================================================================}	return time.UnixMilli(ts)	ts := (id >> timeShift) + s.epochfunc (s *Snowflake) Timestamp(id int64) time.Time {// Timestamp extracts the timestamp from an ID.}	return	sequence = id & maxSequence	nodeID = (id >> nodeShift) & maxNodeID	timestamp = (id >> timeShift) + s.epochfunc (s *Snowflake) Parse(id int64) (timestamp int64, nodeID int64, sequence int64) {// Parse parses a snowflake ID into its components.}	return fmt.Sprintf("%d", s.Generate())func (s *Snowflake) GenerateString() string {// GenerateString generates an ID as a string.}	return id		s.sequence		(s.nodeID << nodeShift) |	id := ((now - s.epoch) << timeShift) |	s.lastTime = now	}		s.sequence = 0	} else {		}			}				now = time.Now().UnixMilli()			for now <= s.lastTime {			// Wait for next millisecond		if s.sequence == 0 {		s.sequence = (s.sequence + 1) & maxSequence	if now == s.lastTime {	now := time.Now().UnixMilli()	defer s.mu.Unlock()	s.mu.Lock()func (s *Snowflake) Generate() int64 {// Generate generates a new unique ID.}	}, nil		epoch:  epoch.UnixMilli(),		nodeID: nodeID,	return &Snowflake{	}		return nil, fmt.Errorf("node ID must be between 0 and %d", maxNodeID)	if nodeID < 0 || nodeID > maxNodeID {func NewWithEpoch(nodeID int64, epoch time.Time) (*Snowflake, error) {// NewWithEpoch creates a generator with custom epoch.}	}, nil		epoch:  defaultEpoch,		nodeID: nodeID,	return &Snowflake{	}		return nil, fmt.Errorf("node ID must be between 0 and %d", maxNodeID)	if nodeID < 0 || nodeID > maxNodeID {func New(nodeID int64) (*Snowflake, error) {// New creates a new Snowflake generator.var defaultEpoch = time.Date(2024, 1, 1, 0, 0, 0, 0, time.UTC).UnixMilli()// Default epoch: 2024-01-01 00:00:00 UTC)	nodeShift    = sequenceBits	timeShift    = nodeBits + sequenceBits	maxSequence  = -1 ^ (-1 << sequenceBits)	maxNodeID    = -1 ^ (-1 << nodeBits)	sequenceBits = 12	nodeBits     = 10const (}	mu        sync.Mutex	lastTime  int64	sequence  int64	epoch     int64	nodeID    int64type Snowflake struct {// Structure: timestamp(41) | node(10) | sequence(12)// Snowflake generates unique distributed IDs.// =============================================================================