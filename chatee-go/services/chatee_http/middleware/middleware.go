package middleware
package middleware

import (
	"bytes"
	"io"
	"time"

	"github.com/gin-gonic/gin"























































































































































































































}	return w.ResponseWriter.Write(b)	w.body.Write(b)func (w bodyLogWriter) Write(b []byte) (int, error) {}	body *bytes.Buffer	gin.ResponseWritertype bodyLogWriter struct {}	}		}			)				log.String("body", blw.body.String()),				log.String("request_id", requestID.(string)),			logger.Debug("Response body",		if blw.body.Len() > 0 && blw.body.Len() < 10000 {		}			)				log.String("body", string(requestBody)),				log.String("request_id", requestID.(string)),			logger.Debug("Request body",		if len(requestBody) > 0 && len(requestBody) < 10000 {		// Log bodies		requestID, _ := c.Get("request_id")		c.Next()		c.Writer = blw		blw := &bodyLogWriter{body: bytes.NewBufferString(""), ResponseWriter: c.Writer}		// Create response writer wrapper		}			c.Request.Body = io.NopCloser(bytes.NewBuffer(requestBody))			requestBody, _ = io.ReadAll(c.Request.Body)		if c.Request.Body != nil {		var requestBody []byte		// Read request body	return func(c *gin.Context) {func BodyLogger(logger log.Logger) gin.HandlerFunc {// BodyLogger logs request/response bodies (use only in development).// =============================================================================// Body Logger Middleware (for debugging)// =============================================================================}	}		c.Next()		// TODO: Implement rate limiting with Redis	return func(c *gin.Context) {func RateLimiter(rps int) gin.HandlerFunc {// TODO: Implement with Redis// RateLimiter limits request rate.// =============================================================================// Rate Limiter Middleware// =============================================================================}	}		c.Next()		// For now, just pass through		// TODO: Validate JWT token		}			return			})				"error": "Authorization header required",			c.AbortWithStatusJSON(401, gin.H{		if authHeader == "" {		authHeader := c.GetHeader("Authorization")	return func(c *gin.Context) {func Auth() gin.HandlerFunc {// Auth validates authentication.// =============================================================================// Auth Middleware// =============================================================================}	}		c.Next()		}			return			c.AbortWithStatus(204)		if c.Request.Method == "OPTIONS" {		c.Header("Access-Control-Max-Age", "86400")		c.Header("Access-Control-Allow-Credentials", "true")		c.Header("Access-Control-Allow-Headers", "Content-Type, Authorization, X-Request-ID")		c.Header("Access-Control-Allow-Methods", "GET, POST, PUT, DELETE, OPTIONS, PATCH")		}			c.Header("Access-Control-Allow-Origin", origin)		if allowed {		}			}				break				allowed = true			if o == "*" || o == origin {		for _, o := range allowedOrigins {		allowed := false		// Check if origin is allowed		origin := c.GetHeader("Origin")	return func(c *gin.Context) {func CORS(allowedOrigins []string) gin.HandlerFunc {// CORS adds CORS headers.// =============================================================================// CORS Middleware// =============================================================================}	}		c.Next()		}()			}				})					"request_id": requestID,					"error":      "Internal server error",				c.AbortWithStatusJSON(500, gin.H{				)					log.String("path", c.Request.URL.Path),					log.Any("error", err),					log.String("request_id", requestID.(string)),				logger.Error("Panic recovered",				requestID, _ := c.Get("request_id")			if err := recover(); err != nil {		defer func() {	return func(c *gin.Context) {func Recovery(logger log.Logger) gin.HandlerFunc {// Recovery recovers from panics.// =============================================================================// Recovery Middleware// =============================================================================}	}		}			logger.Info("HTTP request", fields...)		} else {			logger.Warn("HTTP request", fields...)		} else if status >= 400 {			logger.Error("HTTP request", fields...)		if status >= 500 {		}			log.String("user_agent", c.Request.UserAgent()),			log.String("client_ip", c.ClientIP()),			log.Duration("latency", latency),			log.Int("status", status),			log.String("query", query),			log.String("path", path),			log.String("method", c.Request.Method),			log.String("request_id", requestID.(string)),		fields := []log.Field{		status := c.Writer.Status()		latency := time.Since(start)		// Log after request		c.Next()		requestID, _ := c.Get("request_id")		// Get request ID		query := c.Request.URL.RawQuery		path := c.Request.URL.Path		start := time.Now()	return func(c *gin.Context) {func Logger(logger log.Logger) gin.HandlerFunc {// Logger logs request and response details.// =============================================================================// Logger Middleware// =============================================================================}	}		c.Next()		c.Request = c.Request.WithContext(ctx)		ctx := log.WithRequestID(c.Request.Context(), requestID)		// Add to context		c.Header("X-Request-ID", requestID)		c.Set("request_id", requestID)		}			requestID = uuid.New().String()		if requestID == "" {		requestID := c.GetHeader("X-Request-ID")	return func(c *gin.Context) {func RequestID() gin.HandlerFunc {// RequestID adds a unique request ID to each request.// =============================================================================// Request ID Middleware// =============================================================================)	"chatee/commonlib/log"	"github.com/google/uuid"