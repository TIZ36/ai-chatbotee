package agent
package agent

import (
	"context"
	"encoding/json"
	"fmt"
	"sync"
	"time"




















































































































































































































































































































































































































































}	return a.manager.GetServerForTool(toolName)func (a *mcpManagerAdapter) GetServerForTool(toolName string) string {}	return a.manager.CallTool(ctx, serverName, toolName, args)func (a *mcpManagerAdapter) CallTool(ctx context.Context, serverName, toolName string, args map[string]interface{}) (interface{}, error) {}	return result, nil	}		}			Parameters:  t.InputSchema,			Description: t.Description,			Name:        t.Name,		result[i] = actor.ToolDefinition{	for i, t := range tools {	result := make([]actor.ToolDefinition, len(tools))	}		return nil, err	if err != nil {	tools, err := a.manager.ListAllTools(ctx)func (a *mcpManagerAdapter) ListAllTools(ctx context.Context) ([]actor.ToolDefinition, error) {}	manager *mcp.Managertype mcpManagerAdapter struct {// mcpManagerAdapter adapts the MCP manager interface}	})		return handler(event.Delta)	}, func(event llm.StreamEvent) error {		},			{Role: "user", Content: prompt},			{Role: "system", Content: systemPrompt},		Messages: []llm.Message{		Model: a.model,	return a.provider.ChatStream(ctx, &llm.ChatRequest{func (a *llmProviderAdapter) GenerateStream(ctx context.Context, prompt string, systemPrompt string, handler func(chunk string) error) error {}	return result, nil	}		})			Arguments: args,			Name:      tc.Name,			ID:        tc.ID,		result.ToolCalls = append(result.ToolCalls, actor.ToolCallRequest{		json.Unmarshal([]byte(tc.Arguments), &args)		var args map[string]interface{}	for _, tc := range resp.Message.ToolCalls {	}		Content: resp.Message.Content,	result := &actor.LLMResponse{	}		return nil, err	if err != nil {	})		Tools: llmTools,		},			{Role: "user", Content: prompt},			{Role: "system", Content: systemPrompt},		Messages: []llm.Message{		Model: a.model,	resp, err := a.provider.Chat(ctx, &llm.ChatRequest{	}		}			Parameters:  t.Parameters,			Description: t.Description,			Name:        t.Name,		llmTools[i] = llm.Tool{	for i, t := range tools {	llmTools := make([]llm.Tool, len(tools))func (a *llmProviderAdapter) GenerateWithTools(ctx context.Context, prompt string, systemPrompt string, tools []actor.ToolDefinition) (*actor.LLMResponse, error) {}	return "", nil	}		return resp.Message.Content, nil	if len(resp.Message.Content) > 0 {	}		return "", err	if err != nil {	})		},			{Role: "user", Content: prompt},			{Role: "system", Content: systemPrompt},		Messages: []llm.Message{		Model: a.model,	resp, err := a.provider.Chat(ctx, &llm.ChatRequest{func (a *llmProviderAdapter) GenerateText(ctx context.Context, prompt string, systemPrompt string) (string, error) {}	model    string	provider llm.Providertype llmProviderAdapter struct {// llmProviderAdapter adapts the LLM provider interface}	Errors            int64	ChainExecutions   int64	ToolCalls         int64	MessagesProcessed int64type AgentStats struct {// AgentStats contains agent statistics}	Stats     AgentStats	CreatedAt time.Time	IsActive  bool	SessionID string	AgentID   stringtype AgentStatus struct {// AgentStatus represents the status of an agent}	Error   string	Success bool	Output  map[string]interface{}	Steps   []ChainStepResult	ChainID stringtype ExecuteChainResponse struct {// ExecuteChainResponse is the response from ExecuteChain}	Params     map[string]interface{}	ActionType actor.ActionTypetype ChainStepSpec struct {// ChainStepSpec specifies a step in the chain}	Input     map[string]interface{}	Steps     []ChainStepSpec	ChainID   string	SessionID string	AgentID   stringtype ExecuteChainRequest struct {// ExecuteChainRequest is the request for ExecuteChain}	Duration   time.Duration	Result     interface{}	Status     string	ActionType actor.ActionType	StepID     stringtype ChainStepResult struct {// ChainStepResult represents the result of an action chain step}	Duration   time.Duration	Result     interface{}	Arguments  map[string]interface{}	ServerName string	ToolName   stringtype ToolCallResult struct {// ToolCallResult represents the result of a tool call}	Error     string	ChainStep *ChainStepResult	ToolCall  *ToolCallResult	Content   string	Type      string // "content", "tool_call", "chain_step", "done", "error"type StreamChunk struct {// StreamChunk represents a chunk of streaming response}	ChainSteps []ChainStepResult	ToolCalls  []ToolCallResult	Role       string	Content    string	MessageID  stringtype ProcessMessageResponse struct {// ProcessMessageResponse is the response from ProcessMessage}	Metadata  map[string]string	Content   string	MessageID string	SessionID string	AgentID   stringtype ProcessMessageRequest struct {// ProcessMessageRequest is the request for ProcessMessage}	TTL         time.Duration	MaxMessages int	Enabled     booltype MemoryConfig struct {// MemoryConfig configures agent memory}	MemoryConfig *MemoryConfig	RAGEnabled   bool	MCPServers   []string	Model        string	LLMProvider  string	SystemPrompt string	Description  string	Name         string	ID           stringtype AgentConfig struct {// AgentConfig represents agent configuration from database}	}, nil		Model:        "deepseek-chat",		LLMProvider:  "deepseek",		SystemPrompt: "You are a helpful AI assistant.",		Description:  "AI Assistant",		Name:         "Assistant",		ID:           agentID,	return &AgentConfig{	// For now, return a default config	// TODO: Load from database via DBC servicefunc (s *Service) loadAgentConfig(ctx context.Context, agentID string) (*AgentConfig, error) {// loadAgentConfig loads agent configuration from database}	return nil	delete(s.agentActors, key)	wrapper.Ref.Stop()	}		return nil	if !ok {	wrapper, ok := s.agentActors[key]	defer s.mu.Unlock()	s.mu.Lock()	key := fmt.Sprintf("%s:%s", agentID, sessionID)func (s *Service) StopAgent(ctx context.Context, agentID, sessionID string) error {// StopAgent stops an agent actor}	}, nil		CreatedAt: wrapper.CreatedAt,		IsActive:  true,		SessionID: sessionID,		AgentID:   agentID,	return &AgentStatus{	}		}, nil			IsActive: false,			AgentID:  agentID,		return &AgentStatus{	if !ok {	s.mu.RUnlock()	wrapper, ok := s.agentActors[key]	s.mu.RLock()	key := fmt.Sprintf("%s:%s", agentID, sessionID)func (s *Service) GetAgentStatus(ctx context.Context, agentID, sessionID string) (*AgentStatus, error) {// GetAgentStatus returns the status of an agent}	return s.chainManager.Execute(ctx, req)func (s *Service) ExecuteChain(ctx context.Context, req *ExecuteChainRequest) (*ExecuteChainResponse, error) {// ExecuteChain executes an ActionChain for an agent}	return nil	wrapper.Ref.Send(actor.NewMessage("stream_message", msg))	}		StreamChan: stream,		},			Timestamp: time.Now(),			Content:   req.Content,			Role:      "user",			ID:        req.MessageID,		ChatMessage: actor.ChatMessage{	msg := &actor.StreamingChatMessage{	// Create streaming request	}		return err	if err != nil {	wrapper, err := s.GetOrCreateAgent(ctx, req.AgentID, req.SessionID)func (s *Service) StreamMessage(ctx context.Context, req *ProcessMessageRequest, stream chan<- *StreamChunk) error {// StreamMessage streams a message response from an agent}	}		return nil, fmt.Errorf("timeout waiting for agent response")	case <-time.After(60 * time.Second):		return nil, ctx.Err()	case <-ctx.Done():		return nil, fmt.Errorf("unexpected response type")		}			}, nil				Role:      chatResp.Role,				Content:   chatResp.Content,				MessageID: chatResp.ID,			return &ProcessMessageResponse{		if chatResp, ok := resp.Payload().(*actor.ChatMessage); ok {	case resp := <-respChan:	select {	wrapper.Ref.Send(actor.NewAskMessage("process_message", msg, respChan))	respChan := make(chan actor.Message, 1)	// Send to actor and wait for response	}		Timestamp: time.Now(),		Content:   req.Content,		Role:      "user",		ID:        req.MessageID,	msg := &actor.ChatMessage{	// Create message for actor	}		return nil, err	if err != nil {	wrapper, err := s.GetOrCreateAgent(ctx, req.AgentID, req.SessionID)func (s *Service) ProcessMessage(ctx context.Context, req *ProcessMessageRequest) (*ProcessMessageResponse, error) {// ProcessMessage sends a message to an agent and returns the response}	return wrapper, nil	s.agentActors[key] = wrapper	}		CreatedAt: time.Now(),		SessionID: sessionID,		AgentID:   agentID,		Ref:       ref,	wrapper := &AgentActorWrapper{	ref := s.cfg.ActorSystem.Spawn(aiActor)	})		MCPManager:  &mcpManagerAdapter{manager: s.cfg.MCPManager},		LLMProvider: &llmProviderAdapter{provider: provider, model: agentCfg.Model},		},			Prompt:      agentCfg.SystemPrompt,			Description: agentCfg.Description,			Name:        agentCfg.Name,		Persona: actor.Persona{		SessionID: sessionID,		AgentID:   agentID,	aiActor := actor.NewAIAgentActor(actor.AIAgentConfig{	// Create AI agent actor	}		return nil, fmt.Errorf("LLM provider not found: %s", agentCfg.LLMProvider)	if err != nil {	provider, err := s.cfg.LLMRegistry.Get(agentCfg.LLMProvider)	// Create LLM provider for this agent	}		return nil, fmt.Errorf("failed to load agent config: %w", err)	if err != nil {	agentCfg, err := s.loadAgentConfig(ctx, agentID)	// Load agent config from database	}		return wrapper, nil	if wrapper, ok := s.agentActors[key]; ok {	// Double-check	defer s.mu.Unlock()	s.mu.Lock()	s.mu.RUnlock()	}		return wrapper, nil		s.mu.RUnlock()	if wrapper, ok := s.agentActors[key]; ok {	s.mu.RLock()	key := fmt.Sprintf("%s:%s", agentID, sessionID)func (s *Service) GetOrCreateAgent(ctx context.Context, agentID, sessionID string) (*AgentActorWrapper, error) {// GetOrCreateAgent gets an existing agent actor or creates a new one}	_ = svc	_ = server	// pb.RegisterAgentServiceServer(server, svc)	// Will register proto-generated service interfacefunc RegisterGRPC(server *grpc.Server, svc *Service) {// RegisterGRPC registers the service with a gRPC server}	return s	s.chainManager = NewChainManager(s)	}		agentActors: make(map[string]*AgentActorWrapper),		cfg:         cfg,	s := &Service{func NewService(cfg Config) *Service {// NewService creates a new agent service}	CreatedAt time.Time	SessionID string	AgentID   string	Ref       actor.ActorReftype AgentActorWrapper struct {// AgentActorWrapper wraps an AI agent actor with metadata}	chainManager *ChainManager	mu           sync.RWMutex	agentActors  map[string]*AgentActorWrapper	cfg          Configtype Service struct {// Service implements the Agent gRPC service}	Logger      log.Logger	ActorSystem actor.ActorSystem	MCPManager  *mcp.Manager	LLMRegistry *llm.Registry	Pools       *pool.PoolManagertype Config struct {// Config holds the agent service configuration)	"google.golang.org/grpc"	"chatee-go/commonlib/pool"	"chatee-go/commonlib/mcp"	"chatee-go/commonlib/log"	"chatee-go/commonlib/llm"	"chatee-go/commonlib/actor"