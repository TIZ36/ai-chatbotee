package user
package user

import (
	"context"
	"fmt"
	"sync"













































































































































































































































































































































































































}	}		StreamResponses: true,		EnterToSend:     true,		ShowTimestamps:  true,		CompactMode:     false,		NotifySound:     true,		EnableNotify:    true,		DefaultModel:    "deepseek-chat",		DefaultLLM:      "deepseek",		Language:        "en",		Theme:           "system",	return &UserSettings{func defaultUserSettings() *UserSettings {// defaultUserSettings returns default user settings}	}		Status:    cached["status"],		AvatarURL: cached["avatar_url"],		Name:      cached["name"],		Email:     cached["email"],		ID:        cached["id"],	return &User{func parseUserFromCache(cached map[string]string) *User {// parseUserFromCache parses a user from Redis cache}	redis.Del(ctx, cacheKey)	cacheKey := fmt.Sprintf("user:%s", userID)	redis := s.cfg.Pools.GetRedis()func (s *Service) invalidateUserCache(ctx context.Context, userID string) {// invalidateUserCache invalidates a user's cache}	redis.Expire(ctx, cacheKey, 30*time.Minute)	})		"status":     user.Status,		"avatar_url": user.AvatarURL,		"name":       user.Name,		"email":      user.Email,		"id":         user.ID,	redis.HSet(ctx, cacheKey, map[string]interface{}{	cacheKey := fmt.Sprintf("user:%s", user.ID)	redis := s.cfg.Pools.GetRedis()func (s *Service) cacheUser(ctx context.Context, user *User) {// cacheUser caches a user in Redis}	return &user, nil	}		return nil, fmt.Errorf("user not found: %s", userID)	if err != nil {	err := db.GetContext(ctx, &user, "SELECT id, email, name, avatar_url, status, created_at, updated_at FROM users WHERE id = ?", userID)	var user User	db := s.cfg.Pools.GetMySQL()func (s *Service) loadUser(ctx context.Context, userID string) (*User, error) {// loadUser loads a user from the database}	return err	`, user.ID, user.Email, user.Name, user.AvatarURL, user.Status, "{}", user.CreatedAt, user.UpdatedAt)			updated_at = VALUES(updated_at)			settings = VALUES(settings),			status = VALUES(status),			avatar_url = VALUES(avatar_url),			name = VALUES(name),		ON DUPLICATE KEY UPDATE		VALUES (?, ?, ?, ?, ?, ?, ?, ?)		INSERT INTO users (id, email, name, avatar_url, status, settings, created_at, updated_at)	_, err := db.ExecContext(ctx, `	db := s.cfg.Pools.GetMySQL()func (s *Service) saveUser(ctx context.Context, user *User) error {// saveUser saves a user to the database}	}		delete(s.userActors, userID)		wrapper.Ref.Stop()	if wrapper, ok := s.userActors[userID]; ok {	defer s.mu.Unlock()	s.mu.Lock()func (s *Service) stopUserActor(userID string) {// stopUserActor stops a user actor}	return users, nil	}		users = append(users, userID)	for userID := range s.userActors {	users := make([]string, 0, len(s.userActors))	defer s.mu.RUnlock()	s.mu.RLock()func (s *Service) GetActiveUsers(ctx context.Context) ([]string, error) {// GetActiveUsers returns a list of currently active users}	Connections  int	ActiveChats  []string	LastSeen     time.Time	Online       bool	UserID       stringtype UserStatus struct {// UserStatus represents user online status}	}, nil		Online: true, // Actor exists, so user is online		UserID: userID,	return &UserStatus{	}		return nil, fmt.Errorf("timeout getting user status")	case <-time.After(5 * time.Second):		return nil, ctx.Err()	case <-ctx.Done():		}			return status, nil		if status, ok := resp.Payload().(*UserStatus); ok {	case resp := <-respChan:	select {	wrapper.Ref.Send(actor.NewAskMessage("get_status", nil, respChan))	respChan := make(chan actor.Message, 1)	// Query the actor for status	}		}, nil			Online: false,			UserID: userID,		return &UserStatus{	if !ok {	s.mu.RUnlock()	wrapper, ok := s.userActors[userID]	s.mu.RLock()func (s *Service) GetUserStatus(ctx context.Context, userID string) (*UserStatus, error) {// GetUserStatus returns the online status of a user}	return nil	wrapper.Ref.Send(actor.NewMessage("unregister_connection", connID))	}		return nil	if !ok {	s.mu.RUnlock()	wrapper, ok := s.userActors[userID]	s.mu.RLock()func (s *Service) UnregisterConnection(ctx context.Context, userID string, connID string) error {// UnregisterConnection unregisters a WebSocket connection for a user}	return nil	wrapper.Ref.Send(actor.NewMessage("register_connection", conn))	}		return err	if err != nil {	wrapper, err := s.GetOrCreateUserActor(ctx, userID)func (s *Service) RegisterConnection(ctx context.Context, userID string, conn actor.Connection) error {// RegisterConnection registers a WebSocket connection for a user}	return wrapper, nil	s.userActors[userID] = wrapper	}		CreatedAt: time.Now(),		UserID:    userID,		Ref:       ref,	wrapper := &UserActorWrapper{	ref := s.cfg.ActorSystem.Spawn(userActor)	})		},			AvatarURL: user.AvatarURL,			Email:     user.Email,			Name:      user.Name,			ID:        userID,		Profile: actor.UserProfile{		UserID: userID,	userActor := actor.NewUserActor(actor.UserActorConfig{	// Create user actor	}		return nil, err	if err != nil {	user, err := s.GetUser(ctx, userID)	// Load user from database	}		return wrapper, nil	if wrapper, ok := s.userActors[userID]; ok {	// Double-check	defer s.mu.Unlock()	s.mu.Lock()	s.mu.RUnlock()	}		return wrapper, nil		s.mu.RUnlock()	if wrapper, ok := s.userActors[userID]; ok {	s.mu.RLock()func (s *Service) GetOrCreateUserActor(ctx context.Context, userID string) (*UserActorWrapper, error) {// GetOrCreateUserActor gets or creates a user actor}	return nil	s.stopUserActor(userID)	// Stop user actor if running	s.invalidateUserCache(ctx, userID)	// Invalidate cache	}		return fmt.Errorf("failed to delete user: %w", err)	if err != nil {	_, err := db.ExecContext(ctx, "UPDATE users SET status = 'deleted', updated_at = NOW() WHERE id = ?", userID)	db := s.cfg.Pools.GetMySQL()	// Delete from databasefunc (s *Service) DeleteUser(ctx context.Context, userID string) error {// DeleteUser deletes a user}	return user, nil	s.invalidateUserCache(ctx, user.ID)	// Invalidate cache	}		return nil, err	if err := s.saveUser(ctx, user); err != nil {	// Save to database	user.UpdatedAt = time.Now()	}		user.Settings = req.Settings	if req.Settings != nil {	}		user.AvatarURL = req.AvatarURL	if req.AvatarURL != "" {	}		user.Name = req.Name	if req.Name != "" {	}		return nil, err	if err != nil {	user, err := s.GetUser(ctx, req.UserID)func (s *Service) UpdateUser(ctx context.Context, req *UpdateUserRequest) (*User, error) {// UpdateUser updates a user}	return user, nil	s.cacheUser(ctx, user)	// Cache the user	}		return nil, err	if err != nil {	user, err := s.loadUser(ctx, userID)	// Load from database	}		return parseUserFromCache(cached), nil	if err == nil && len(cached) > 0 {	cached, err := redis.HGetAll(ctx, cacheKey).Result()	// Try to get from cache	cacheKey := fmt.Sprintf("user:%s", userID)	redis := s.cfg.Pools.GetRedis()	// Try cache firstfunc (s *Service) GetUser(ctx context.Context, userID string) (*User, error) {// GetUser retrieves a user by ID}	return user, nil	}		return nil, fmt.Errorf("failed to save user: %w", err)	if err := s.saveUser(ctx, user); err != nil {	// Save to database	}		UpdatedAt: time.Now(),		CreatedAt: time.Now(),		Settings:  defaultUserSettings(),		Status:    "active",		Name:      req.Name,		Email:     req.Email,		ID:        userID,	user := &User{	userID := snowflake.GenerateTypedID("usr")func (s *Service) CreateUser(ctx context.Context, req *CreateUserRequest) (*User, error) {// CreateUser creates a new user}	Settings  *UserSettings	AvatarURL string	Name      string	UserID    stringtype UpdateUserRequest struct {// UpdateUserRequest represents a request to update a user}	Password string	Name     string	Email    stringtype CreateUserRequest struct {// CreateUserRequest represents a request to create a user}	StreamResponses  bool	EnterToSend      bool	ShowTimestamps   bool	CompactMode      bool	NotifySound      bool	EnableNotify     bool	DefaultModel     string	DefaultLLM       string	Language         string	Theme            stringtype UserSettings struct {// UserSettings represents user settings}	UpdatedAt time.Time	CreatedAt time.Time	Settings  *UserSettings	Status    string	AvatarURL string	Name      string	Email     string	ID        stringtype User struct {// User represents a user}	_ = svc	_ = server	// pb.RegisterUserServiceServer(server, svc)	// Will register proto-generated service interfacefunc RegisterGRPC(server *grpc.Server, svc *Service) {// RegisterGRPC registers the service with a gRPC server}	}		userActors: make(map[string]*UserActorWrapper),		cfg:        cfg,	return &Service{func NewService(cfg Config) *Service {// NewService creates a new user service}	CreatedAt time.Time	UserID    string	Ref       actor.ActorReftype UserActorWrapper struct {// UserActorWrapper wraps a user actor with metadata}	mu         sync.RWMutex	userActors map[string]*UserActorWrapper	cfg        Configtype Service struct {// Service implements the User gRPC service}	Logger      log.Logger	ActorSystem actor.ActorSystem	Pools       *pool.PoolManagertype Config struct {// Config holds the user service configuration)	"google.golang.org/grpc"	"chatee-go/commonlib/snowflake"	"chatee-go/commonlib/pool"	"chatee-go/commonlib/log"	"chatee-go/commonlib/actor"	"time"