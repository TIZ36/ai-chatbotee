package mcp
package mcp

import (
	"context"
























































































































































































































































































































































































}	UserID     string	Enabled    bool	AuthHeader string	AuthToken  string	AuthType   string	URL        string	Name       string	ID         stringtype MCPServerConfig struct {// MCPServerConfig represents MCP server configuration in database}	return nil, fmt.Errorf("not implemented")	// TODO: Load from database via DBC servicefunc (s *Service) LoadServerConfig(ctx context.Context, serverID string) (*MCPServerConfig, error) {// LoadServerConfig loads MCP server configuration from database}	return nil	// TODO: Save to database via DBC servicefunc (s *Service) SaveServerConfig(ctx context.Context, cfg *MCPServerConfig) error {// SaveServerConfig saves MCP server configuration to database}	return s.cfg.Manager.GetPrompt(ctx, serverName, promptName, args)	defer s.serversMu.RUnlock()	s.serversMu.RLock()func (s *Service) GetPrompt(ctx context.Context, serverName, promptName string, args map[string]string) (string, error) {// GetPrompt gets a prompt from an MCP server}	return result, nil	}		}			result = append(result, prompt)			}				})					Required:    arg.Required,					Description: arg.Description,					Name:        arg.Name,				prompt.Arguments = append(prompt.Arguments, PromptArgument{			for _, arg := range p.Arguments {			}				ServerName:  server.Name,				Description: p.Description,				Name:        p.Name,			prompt := Prompt{		for _, p := range prompts {		}			continue			s.cfg.Logger.Warn("Failed to list prompts", "server", server.Name, "error", err)		if err != nil {		prompts, err := s.cfg.Manager.ListPrompts(ctx, server.Name)		}			continue		if !server.Connected {	for _, server := range servers {	result := make([]Prompt, 0)	servers := s.cfg.Manager.ListServers()	defer s.serversMu.RUnlock()	s.serversMu.RLock()func (s *Service) ListPrompts(ctx context.Context) ([]Prompt, error) {// ListPrompts returns all prompts from all connected servers}	return s.cfg.Manager.ReadResource(ctx, serverName, uri)	defer s.serversMu.RUnlock()	s.serversMu.RLock()func (s *Service) ReadResource(ctx context.Context, serverName, uri string) ([]byte, string, error) {// ReadResource reads a resource from an MCP server}	return result, nil	}		}			})				ServerName:  server.Name,				MimeType:    r.MimeType,				Description: r.Description,				Name:        r.Name,				URI:         r.URI,			result = append(result, Resource{		for _, r := range resources {		}			continue			s.cfg.Logger.Warn("Failed to list resources", "server", server.Name, "error", err)		if err != nil {		resources, err := s.cfg.Manager.ListResources(ctx, server.Name)		}			continue		if !server.Connected {	for _, server := range servers {	result := make([]Resource, 0)	servers := s.cfg.Manager.ListServers()	defer s.serversMu.RUnlock()	s.serversMu.RLock()func (s *Service) ListResources(ctx context.Context) ([]Resource, error) {// ListResources returns all resources from all connected servers}	}, nil		Result:  result,		Success: true,	return &ToolCallResponse{	}		}, nil			IsError: true,			Error:   err.Error(),			Success: false,		return &ToolCallResponse{	if err != nil {	result, err := s.cfg.Manager.CallTool(ctx, req.ServerName, req.ToolName, req.Arguments)	defer s.serversMu.RUnlock()	s.serversMu.RLock()func (s *Service) CallTool(ctx context.Context, req *ToolCallRequest) (*ToolCallResponse, error) {// CallTool calls a tool on an MCP server}	return result, nil	}		}			ServerName:  serverName,			InputSchema: t.InputSchema,			Description: t.Description,			Name:        t.Name,		result[i] = Tool{	for i, t := range mcpTools {	result := make([]Tool, len(mcpTools))	}		return nil, err	if err != nil {	mcpTools, err := s.cfg.Manager.ListTools(ctx, serverName)	defer s.serversMu.RUnlock()	s.serversMu.RLock()func (s *Service) ListServerTools(ctx context.Context, serverName string) ([]Tool, error) {// ListServerTools returns tools from a specific server}	return result, nil	}		}			ServerName:  s.cfg.Manager.GetServerForTool(t.Name),			InputSchema: t.InputSchema,			Description: t.Description,			Name:        t.Name,		result[i] = Tool{	for i, t := range mcpTools {	result := make([]Tool, len(mcpTools))	}		return nil, err	if err != nil {	mcpTools, err := s.cfg.Manager.ListAllTools(ctx)	defer s.serversMu.RUnlock()	s.serversMu.RLock()func (s *Service) ListTools(ctx context.Context) ([]Tool, error) {// ListTools returns all tools from all connected servers}	return s.cfg.Manager.RemoveServer(serverName)	defer s.serversMu.Unlock()	s.serversMu.Lock()func (s *Service) RemoveServer(ctx context.Context, serverName string) error {// RemoveServer removes an MCP server configuration}	return s.cfg.Manager.AddServer(name, url, auth)	}		Header: authHeader,		Token:  authToken,		Type:   authType,	auth := &mcp.AuthConfig{	defer s.serversMu.Unlock()	s.serversMu.Lock()func (s *Service) AddServer(ctx context.Context, name, url string, authType, authToken, authHeader string) error {// AddServer adds a new MCP server configuration}	return s.cfg.Manager.Disconnect(serverName)	defer s.serversMu.Unlock()	s.serversMu.Lock()func (s *Service) DisconnectServer(ctx context.Context, serverName string) error {// DisconnectServer disconnects from an MCP server}	return s.cfg.Manager.Connect(ctx, serverName)	defer s.serversMu.Unlock()	s.serversMu.Lock()func (s *Service) ConnectServer(ctx context.Context, serverName string) error {// ConnectServer connects to an MCP server}	return info, nil	}		info.ResourceCount = len(resources)		resources, _ := s.cfg.Manager.ListResources(ctx, server.Name)		info.ToolCount = len(tools)		tools, _ := s.cfg.Manager.ListTools(ctx, server.Name)	if server.Connected {	}		info.Capabilities = server.ServerInfo.Capabilities		info.ProtocolVersion = server.ServerInfo.ProtocolVersion	if server.Connected && server.ServerInfo != nil {	}		Connected: server.Connected,		URL:       server.URL,		Name:      server.Name,	info := &ServerInfo{	}		return nil, err	if err != nil {	server, err := s.cfg.Manager.GetServer(serverName)	defer s.serversMu.RUnlock()	s.serversMu.RLock()func (s *Service) GetServer(ctx context.Context, serverName string) (*ServerInfo, error) {// GetServer returns information about a specific server}	return result, nil	}		result = append(result, info)		}			info.ResourceCount = len(resources)			resources, _ := s.cfg.Manager.ListResources(ctx, server.Name)			info.ToolCount = len(tools)			tools, _ := s.cfg.Manager.ListTools(ctx, server.Name)		if server.Connected {		// Count tools and resources		}			info.Capabilities = server.ServerInfo.Capabilities			info.ProtocolVersion = server.ServerInfo.ProtocolVersion		if server.Connected && server.ServerInfo != nil {		}			Connected: server.Connected,			URL:       server.URL,			Name:      server.Name,		info := ServerInfo{	for _, server := range servers {	result := make([]ServerInfo, 0, len(servers))	servers := s.cfg.Manager.ListServers()	defer s.serversMu.RUnlock()	s.serversMu.RLock()func (s *Service) ListServers(ctx context.Context) ([]ServerInfo, error) {// ListServers returns a list of configured MCP servers}	IsError bool	Error   string	Result  interface{}	Success booltype ToolCallResponse struct {// ToolCallResponse represents the response from a tool call}	Arguments  map[string]interface{}	ToolName   string	ServerName stringtype ToolCallRequest struct {// ToolCallRequest represents a request to call a tool}	Required    bool	Description string	Name        stringtype PromptArgument struct {// PromptArgument represents a prompt argument}	ServerName  string	Arguments   []PromptArgument	Description string	Name        stringtype Prompt struct {// Prompt represents an MCP prompt}	ServerName  string	MimeType    string	Description string	Name        string	URI         stringtype Resource struct {// Resource represents an MCP resource}	ServerName  string	InputSchema map[string]interface{}	Description string	Name        stringtype Tool struct {// Tool represents an MCP tool}	ResourceCount  int	ToolCount      int	Capabilities   []string	ProtocolVersion string	Connected      bool	URL            string	Name           stringtype ServerInfo struct {// ServerInfo contains information about an MCP server}	_ = svc	_ = server	// pb.RegisterMCPServiceServer(server, svc)	// Will register proto-generated service interfacefunc RegisterGRPC(server *grpc.Server, svc *Service) {// RegisterGRPC registers the service with a gRPC server}	}		cfg: cfg,	return &Service{func NewService(cfg Config) *Service {// NewService creates a new MCP service}	serversMu sync.RWMutex	cfg       Configtype Service struct {// Service implements the MCP gRPC service}	Logger  log.Logger	Pools   *pool.PoolManager	Manager *mcp.Managertype Config struct {// Config holds the MCP service configuration)	"google.golang.org/grpc"	"chatee-go/commonlib/pool"	"chatee-go/commonlib/mcp"	"chatee-go/commonlib/log"	"sync"	"fmt"