package cmd
package main

import (




























































































































































































}	}		return err		}			logger.Error("gRPC stream error", "method", info.FullMethod, "error", err)		if err != nil {		err := handler(srv, ss)		logger.Debug("gRPC stream call", "method", info.FullMethod)	return func(srv interface{}, ss grpc.ServerStream, info *grpc.StreamServerInfo, handler grpc.StreamHandler) error {func streamServerInterceptor(logger log.Logger) grpc.StreamServerInterceptor {// streamServerInterceptor logs streaming RPC calls}	}		return resp, err		}			logger.Error("gRPC error", "method", info.FullMethod, "error", err)		if err != nil {		resp, err := handler(ctx, req)		logger.Debug("gRPC unary call", "method", info.FullMethod)	return func(ctx context.Context, req interface{}, info *grpc.UnaryServerInfo, handler grpc.UnaryHandler) (interface{}, error) {func unaryServerInterceptor(logger log.Logger) grpc.UnaryServerInterceptor {// unaryServerInterceptor logs unary RPC calls}	}		os.Exit(1)		logger.Error("gRPC server failed", "error", err)	if err := grpcServer.Serve(listener); err != nil {	logger.Info("ChateeSvr listening", "address", addr)	}()		pools.Close()		actorSystem.Shutdown()		grpcServer.GracefulStop()		healthServer.SetServingStatus("chatee-svr", grpc_health_v1.HealthCheckResponse_NOT_SERVING)		logger.Info("Shutting down gracefully...")		<-sigChan	go func() {	signal.Notify(sigChan, syscall.SIGINT, syscall.SIGTERM)	sigChan := make(chan os.Signal, 1)	// Handle shutdown signals	}		os.Exit(1)		logger.Error("Failed to listen", "address", addr, "error", err)	if err != nil {	listener, err := net.Listen("tcp", addr)	addr := cfg.GetGRPCAddress("svr")	// Start listening	reflection.Register(grpcServer)	// Enable reflection for development	healthServer.SetServingStatus("chatee-svr", grpc_health_v1.HealthCheckResponse_SERVING)	grpc_health_v1.RegisterHealthServer(grpcServer, healthServer)	healthServer := health.NewServer()	// Register health check	usermod.RegisterGRPC(grpcServer, userService)	mcpmod.RegisterGRPC(grpcServer, mcpService)	llmmod.RegisterGRPC(grpcServer, llmService)	agentmod.RegisterGRPC(grpcServer, agentService)	// Register services	)		grpc.StreamInterceptor(streamServerInterceptor(logger)),		grpc.UnaryInterceptor(unaryServerInterceptor(logger)),	grpcServer := grpc.NewServer(	// Create gRPC server	})		Logger:      logger,		ActorSystem: actorSystem,		Pools:       pools,	userService := usermod.NewService(usermod.Config{	})		Logger:  logger,		Pools:   pools,		Manager: mcpManager,	mcpService := mcpmod.NewService(mcpmod.Config{	})		Logger:   logger,		Pools:    pools,		Registry: llmRegistry,	llmService := llmmod.NewService(llmmod.Config{	})		Logger:      logger,		ActorSystem: actorSystem,		MCPManager:  mcpManager,		LLMRegistry: llmRegistry,		Pools:       pools,	agentService := agentmod.NewService(agentmod.Config{	// Create service modules	actorSystem := actor.NewActorSystem("chatee-svr")	// Initialize Actor system	}		}			logger.Warn("Failed to add MCP server", "name", serverCfg.Name, "error", err)		if err != nil {		})			Header: serverCfg.AuthHeader,			Token:  serverCfg.AuthToken,			Type:   serverCfg.AuthType,		err := mcpManager.AddServer(serverCfg.Name, serverCfg.URL, &mcp.AuthConfig{	for _, serverCfg := range cfg.MCP.Servers {	mcpManager := mcp.NewManager()	// Initialize MCP manager	}		llmRegistry.Register(name, provider)		}			continue			logger.Warn("Failed to create LLM provider", "name", name, "error", err)		if err != nil {		provider, err := llm.CreateProvider(name, providerCfg.APIKey, providerCfg.BaseURL, providerCfg.DefaultModel)	for name, providerCfg := range cfg.LLM.Providers {	llmRegistry := llm.NewRegistry()	// Initialize LLM providers	pools.SetRedis(redisPool)	)		cfg.Redis.PoolSize,		cfg.Redis.DB,		cfg.Redis.Password,		cfg.Redis.Port,		cfg.Redis.Host,	redisPool := pool.NewRedisPool(	pools.SetMySQL(mysqlPool)	}		os.Exit(1)		logger.Error("Failed to create MySQL pool", "error", err)	if err != nil {	)		cfg.MySQL.MaxIdleConns,		cfg.MySQL.MaxOpenConns,		cfg.MySQL.Database,		cfg.MySQL.Password,		cfg.MySQL.User,		cfg.MySQL.Port,		cfg.MySQL.Host,	mysqlPool, err := pool.NewMySQLPool(	pools := pool.NewPoolManager()	// Initialize connection pools	logger.Info("Starting ChateeSvr service", "version", "1.0.0")	log.SetGlobal(logger)	logger := log.NewLogger(cfg.Log.Level, cfg.Log.Format, cfg.Log.Output)	// Initialize logger	}		panic("failed to load config: " + err.Error())	if err != nil {	cfg, err := config.Load("configs/config.yaml")	// Load configurationfunc main() {)	"google.golang.org/grpc/reflection"	"google.golang.org/grpc/health/grpc_health_v1"	"google.golang.org/grpc/health"	"google.golang.org/grpc"	usermod "chatee-go/services/chatee-svr/internal/user"	mcpmod "chatee-go/services/chatee-svr/internal/mcp"	llmmod "chatee-go/services/chatee-svr/internal/llm"	agentmod "chatee-go/services/chatee-svr/internal/agent"	"chatee-go/commonlib/pool"	"chatee-go/commonlib/mcp"	"chatee-go/commonlib/log"	"chatee-go/commonlib/llm"	"chatee-go/commonlib/config"	"chatee-go/commonlib/actor"	"syscall"	"os/signal"	"os"	"net"	"context"