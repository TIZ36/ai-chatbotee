package connection
package connection

import (
	"encoding/json"
	"net/http"
	"time"

	"github.com/gin-gonic/gin"
	"github.com/gorilla/websocket"
	"github.com/google/uuid"

	"chatee/commonlib/config"
	"chatee/commonlib/log"
	"chatee/services/chatee-conn/hub"
)

// =============================================================================
// WebSocket Upgrader














































































































































































































































































































































}	})		},			"code": code,		Payload: map[string]any{		Timestamp: time.Now().UnixMilli(),		Error:     message,		Type:      "error",	c.sendMessage(OutgoingMessage{func (c *Client) sendError(code, message string) {// sendError sends an error message.}	}		c.logger.Warn("Send buffer full")	default:	case c.hubConn.Send <- data:	select {	}		return		c.logger.Error("Failed to marshal message", log.Error(err))	if err != nil {	data, err := json.Marshal(msg)func (c *Client) sendMessage(msg OutgoingMessage) {// sendMessage sends a message to the client.// =============================================================================// Helper Methods// =============================================================================}	}		c.hub.SendToSession(payload.SessionID, data)		})			},				"is_typing":  payload.IsTyping,				"session_id": payload.SessionID,				"user_id":    c.hubConn.UserID,			Payload: map[string]any{			Timestamp: time.Now().UnixMilli(),			Type:      "user_typing",		data, _ := json.Marshal(OutgoingMessage{	if payload.SessionID != "" {	// Broadcast typing status to session	}		return	if err := json.Unmarshal(msg.Payload, &payload); err != nil {	}		IsTyping  bool   `json:"is_typing"`		SessionID string `json:"session_id"`	var payload struct {func (c *Client) handleTyping(msg IncomingMessage) {// handleTyping handles typing indicator.}	})		Timestamp: time.Now().UnixMilli(),		ID:        msg.ID,		Type:      "message_received",	c.sendMessage(OutgoingMessage{	// Acknowledge receipt	)		log.String("session_id", c.hubConn.SessionID),		log.String("user_id", c.hubConn.UserID),	c.logger.Info("Chat message received",	// TODO: Forward to ChateeSvr via gRPCfunc (c *Client) handleChatMessage(msg IncomingMessage) {// handleChatMessage handles a chat message.}	})		Timestamp: time.Now().UnixMilli(),		ID:        msg.ID,		Type:      "unsubscribed",	c.sendMessage(OutgoingMessage{	c.hubConn.SessionID = ""func (c *Client) handleUnsubscribe(msg IncomingMessage) {// handleUnsubscribe unsubscribes from a channel/session.}	})		},			"channel":    payload.Channel,			"session_id": payload.SessionID,		Payload: map[string]any{		Timestamp: time.Now().UnixMilli(),		ID:        msg.ID,		Type:      "subscribed",	c.sendMessage(OutgoingMessage{	}		c.hubConn.SessionID = payload.SessionID	if payload.SessionID != "" {	// Update session ID	}		return		c.sendError("invalid_payload", "Invalid subscribe payload")	if err := json.Unmarshal(msg.Payload, &payload); err != nil {	}		Channel   string `json:"channel"`		SessionID string `json:"session_id"`	var payload struct {func (c *Client) handleSubscribe(msg IncomingMessage) {// handleSubscribe subscribes to a channel/session.}	}		c.sendError("unknown_type", "Unknown message type: "+msg.Type)	default:		c.handleTyping(msg)	case "typing":		c.handleChatMessage(msg)	case "message":		c.handleUnsubscribe(msg)	case "unsubscribe":		c.handleSubscribe(msg)	case "subscribe":		})			Timestamp: time.Now().UnixMilli(),			ID:        msg.ID,			Type:      "pong",		c.sendMessage(OutgoingMessage{	case "ping":	switch msg.Type {	)		log.String("id", msg.ID),		log.String("type", msg.Type),	c.logger.Debug("Received message",	}		return		c.sendError("invalid_message", "Invalid JSON format")	if err := json.Unmarshal(data, &msg); err != nil {	var msg IncomingMessagefunc (c *Client) handleMessage(data []byte) {// handleMessage processes an incoming message.// =============================================================================// Message Handling// =============================================================================}	}		}			}				return			if err := c.conn.WriteMessage(websocket.PingMessage, nil); err != nil {			c.conn.SetWriteDeadline(time.Now().Add(10 * time.Second))		case <-ticker.C:			}				return			if err := w.Close(); err != nil {			}				w.Write(<-c.hubConn.Send)				w.Write([]byte{'\n'})			for i := 0; i < n; i++ {			n := len(c.hubConn.Send)			// Write queued messages			w.Write(message)			}				return			if err != nil {			w, err := c.conn.NextWriter(websocket.TextMessage)			}				return				c.conn.WriteMessage(websocket.CloseMessage, []byte{})				// Hub closed the channel			if !ok {			c.conn.SetWriteDeadline(time.Now().Add(10 * time.Second))		case message, ok := <-c.hubConn.Send:		select {	for {	}()		c.conn.Close()		ticker.Stop()	defer func() {	ticker := time.NewTicker(c.config.PingInterval)func (c *Client) writePump() {// writePump writes messages to the WebSocket connection.// =============================================================================// Write Pump// =============================================================================}	}		c.handleMessage(message)		c.hubConn.LastActive = time.Now()		}			break			}				c.logger.Error("WebSocket read error", log.Error(err))			if websocket.IsUnexpectedCloseError(err, websocket.CloseGoingAway, websocket.CloseAbnormalClosure) {		if err != nil {		_, message, err := c.conn.ReadMessage()	for {	})		return nil		c.hubConn.LastActive = time.Now()		c.conn.SetReadDeadline(time.Now().Add(c.config.PongWait))	c.conn.SetPongHandler(func(string) error {	c.conn.SetReadDeadline(time.Now().Add(c.config.PongWait))	c.conn.SetReadLimit(c.config.MaxMessageSize)	}()		c.conn.Close()		c.hub.Unregister(c.hubConn)	defer func() {func (c *Client) readPump() {// readPump reads messages from the WebSocket connection.// =============================================================================// Read Pump// =============================================================================}	})		},			"session_id":    sessionID,			"user_id":       userID,			"connection_id": hubConn.ID,		Payload: map[string]any{		Timestamp: time.Now().UnixMilli(),		ID:        hubConn.ID,		Type:      "connected",	client.sendMessage(OutgoingMessage{	// Send welcome message	go client.readPump()	go client.writePump()	// Start read/write pumps	}		logger:  logger.With(log.String("connection_id", hubConn.ID)),		config:  cfg,		hubConn: hubConn,		hub:     h,		conn:    conn,	client := &Client{	// Create client	h.Register(hubConn)	// Register with hub	}		Metadata:   make(map[string]any),		LastActive: time.Now(),		JoinedAt:   time.Now(),		Hub:        h,		Send:       make(chan []byte, 256),		SessionID:  sessionID,		UserID:     userID,		ID:         uuid.New().String(),	hubConn := &hub.Connection{	// Create connection	}		return		logger.Error("Failed to upgrade WebSocket", log.Error(err))	if err != nil {	conn, err := upgrader.Upgrade(c.Writer, c.Request, nil)	// Upgrade connection	sessionID := c.Query("session_id")	userID := c.Query("user_id")	// Get user info from context/queryfunc HandleWebSocket(c *gin.Context, h *hub.Hub, cfg config.WebSocketConfig, logger log.Logger) {// HandleWebSocket handles WebSocket upgrade and communication.// =============================================================================// WebSocket Handler// =============================================================================}	Timestamp int64  `json:"timestamp"`	Error     string `json:"error,omitempty"`	Payload   any    `json:"payload,omitempty"`	ID        string `json:"id,omitempty"`	Type      string `json:"type"`type OutgoingMessage struct {// OutgoingMessage represents a message to client.}	Payload json.RawMessage `json:"payload,omitempty"`	ID      string          `json:"id,omitempty"`	Type    string          `json:"type"`type IncomingMessage struct {// IncomingMessage represents a message from client.// =============================================================================// Message Types// =============================================================================}	logger log.Logger	config config.WebSocketConfig	hubConn *hub.Connection	hub    *hub.Hub	conn   *websocket.Conntype Client struct {// Client represents a WebSocket client.// =============================================================================// Client// =============================================================================}	},		return true		// TODO: Implement proper origin checking	CheckOrigin: func(r *http.Request) bool {	WriteBufferSize: 1024,	ReadBufferSize:  1024,var upgrader = websocket.Upgrader{// =============================================================================