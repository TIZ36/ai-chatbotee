package hub
package hub

import (
	"sync"
	"time"

	"chatee/commonlib/log"
)

















































































































































































































































































































}	return ok	_, ok := h.userConnections[userID]	defer h.mu.RUnlock()	h.mu.RLock()func (h *Hub) IsUserOnline(userID string) bool {// IsUserOnline checks if a user has any active connections.}	return nil	}		return result		}			result = append(result, conn)		for _, conn := range conns {		result := make([]*Connection, 0, len(conns))	if conns, ok := h.userConnections[userID]; ok {	defer h.mu.RUnlock()	h.mu.RLock()func (h *Hub) GetUserConnections(userID string) []*Connection {// GetUserConnections returns all connections for a user.}	return conn, ok	conn, ok := h.connections[id]	defer h.mu.RUnlock()	h.mu.RLock()func (h *Hub) GetConnection(id string) (*Connection, bool) {// GetConnection returns a connection by ID.}	return len(h.userConnections)	defer h.mu.RUnlock()	h.mu.RLock()func (h *Hub) UserCount() int {// UserCount returns the number of connected users.}	return len(h.connections)	defer h.mu.RUnlock()	h.mu.RLock()func (h *Hub) ConnectionCount() int {// ConnectionCount returns the number of active connections.}	}		Data:      data,		Broadcast: true,	h.broadcast <- &Message{func (h *Hub) BroadcastAll(data []byte) {// BroadcastAll sends to all connections.}	}		Data:      data,		SessionID: sessionID,	h.broadcast <- &Message{func (h *Hub) SendToSession(sessionID string, data []byte) {// SendToSession sends to all connections in a session.}	}		Data:   data,		UserID: userID,	h.broadcast <- &Message{func (h *Hub) SendToUser(userID string, data []byte) {// SendToUser sends to all user connections.}	}		Data:         data,		ConnectionID: connID,	h.broadcast <- &Message{func (h *Hub) SendToConnection(connID string, data []byte) {// SendToConnection sends to a specific connection.}	h.broadcast <- msgfunc (h *Hub) Broadcast(msg *Message) {// Broadcast broadcasts a message.}	h.unregister <- connfunc (h *Hub) Unregister(conn *Connection) {// Unregister unregisters a connection.}	h.register <- connfunc (h *Hub) Register(conn *Connection) {// Register registers a connection.// =============================================================================// Public Methods// =============================================================================}	h.config.Logger.Info("Hub cleaned up")	h.userConnections = make(map[string]map[string]*Connection)	h.connections = make(map[string]*Connection)	}		close(conn.Send)	for _, conn := range h.connections {	defer h.mu.Unlock()	h.mu.Lock()func (h *Hub) cleanup() {// cleanup closes all connections.}	}		delete(h.connections, conn.ID)		close(conn.Send)		)			log.String("connection_id", conn.ID),		h.config.Logger.Warn("Connection buffer full, closing",		// Buffer full, close connection	default:		conn.LastActive = time.Now()	case conn.Send <- data:	select {func (h *Hub) sendToConnection(conn *Connection, data []byte) {// sendToConnection sends data to a connection.}	}		}			}				h.sendToConnection(conn, msg.Data)			if conn.SessionID == msg.SessionID {		for _, conn := range h.connections {		// Send to all connections in session	case msg.SessionID != "":		}			}				h.sendToConnection(conn, msg.Data)			for _, conn := range conns {		if conns, ok := h.userConnections[msg.UserID]; ok {		// Send to all user connections	case msg.UserID != "":		}			h.sendToConnection(conn, msg.Data)		if conn, ok := h.connections[msg.ConnectionID]; ok {		// Send to specific connection	case msg.ConnectionID != "":		}			h.sendToConnection(conn, msg.Data)		for _, conn := range h.connections {		// Send to all connections	case msg.Broadcast:	switch {	defer h.mu.RUnlock()	h.mu.RLock()func (h *Hub) handleBroadcast(msg *Message) {// handleBroadcast sends a message to appropriate connections.}	}		)			log.Int("total_connections", len(h.connections)),			log.String("user_id", conn.UserID),			log.String("connection_id", conn.ID),		h.config.Logger.Info("Connection unregistered",		}			}				delete(h.userConnections, conn.UserID)			if len(h.userConnections[conn.UserID]) == 0 {			delete(h.userConnections[conn.UserID], conn.ID)		if conn.UserID != "" && h.userConnections[conn.UserID] != nil {		// Remove from user connections		close(conn.Send)		delete(h.connections, conn.ID)	if _, ok := h.connections[conn.ID]; ok {	defer h.mu.Unlock()	h.mu.Lock()func (h *Hub) unregisterConnection(conn *Connection) {// unregisterConnection removes a connection.}	)		log.Int("total_connections", len(h.connections)),		log.String("user_id", conn.UserID),		log.String("connection_id", conn.ID),	h.config.Logger.Info("Connection registered",	}		h.userConnections[conn.UserID][conn.ID] = conn		}			h.userConnections[conn.UserID] = make(map[string]*Connection)		if h.userConnections[conn.UserID] == nil {	if conn.UserID != "" {	// Add to user connections	h.connections[conn.ID] = conn	defer h.mu.Unlock()	h.mu.Lock()func (h *Hub) registerConnection(conn *Connection) {// registerConnection registers a new connection.}	close(h.done)func (h *Hub) Shutdown() {// Shutdown stops the hub.}	}		}			h.handleBroadcast(msg)		case msg := <-h.broadcast:			h.unregisterConnection(conn)		case conn := <-h.unregister:			h.registerConnection(conn)		case conn := <-h.register:			return			h.cleanup()		case <-h.done:		select {	for {func (h *Hub) Run() {// Run starts the hub's main loop.}	}		done:            make(chan struct{}),		config:          config,		broadcast:       make(chan *Message, 1000),		unregister:      make(chan *Connection, 100),		register:        make(chan *Connection, 100),		userConnections: make(map[string]map[string]*Connection),		connections:     make(map[string]*Connection),	return &Hub{func NewHub(config HubConfig) *Hub {// NewHub creates a new hub.}	Type string // message, event, error	Data []byte	// Content	Broadcast    bool     // All connections	SessionID    string   // All connections in a session	UserID       string   // All connections for a user	ConnectionID string   // Specific connection	// Targettype Message struct {// Message represents a message to broadcast.}	Metadata   map[string]any	LastActive time.Time	JoinedAt   time.Time	Hub        *Hub	Send       chan []byte	SessionID  string	UserID     string	ID         stringtype Connection struct {// Connection represents a WebSocket connection.}	PongWait     time.Duration	PingInterval time.Duration	Logger       log.Loggertype HubConfig struct {// HubConfig configures the hub.}	done chan struct{}	// Shutdown	mu sync.RWMutex	// Mutex for thread safety	config HubConfig	// Configuration	broadcast  chan *Message	unregister chan *Connection	register   chan *Connection	// Channels for communication	userConnections map[string]map[string]*Connection	// Connections by user ID (a user can have multiple connections)	connections map[string]*Connection	// Registered connections by IDtype Hub struct {// Hub maintains active connections and broadcasts messages.// =============================================================================// Hub - Manages all WebSocket connections// =============================================================================