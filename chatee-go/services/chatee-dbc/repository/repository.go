package repository
package repository

import (
	"context"
	"database/sql"
	"encoding/json"
	"fmt"


















































































































































































































































































































































































































































































































































































}	return servers, nil	}		return nil, err	if err := r.db.SelectContext(ctx, &servers, query); err != nil {	query := `SELECT * FROM mcp_servers ORDER BY created_at DESC`	var servers []*MCPServerfunc (r *mysqlMCPServerRepository) List(ctx context.Context) ([]*MCPServer, error) {}	return err	_, err := r.db.ExecContext(ctx, query, id)	query := `DELETE FROM mcp_servers WHERE id = ?`func (r *mysqlMCPServerRepository) Delete(ctx context.Context, id string) error {}	return err	_, err := r.db.NamedExecContext(ctx, query, server)		updated_at = :updated_at WHERE id = :id`		auth_type = :auth_type, auth_config = :auth_config, is_enabled = :is_enabled,		url = :url, command = :command, args = :args, env = :env, headers = :headers,	query := `UPDATE mcp_servers SET name = :name, description = :description, type = :type,func (r *mysqlMCPServerRepository) Update(ctx context.Context, server *MCPServer) error {}	return servers, nil	}		return nil, err	if err := r.db.SelectContext(ctx, &servers, query, userID); err != nil {	query := `SELECT * FROM mcp_servers WHERE user_id = ? ORDER BY created_at DESC`	var servers []*MCPServerfunc (r *mysqlMCPServerRepository) GetByUserID(ctx context.Context, userID string) ([]*MCPServer, error) {}	return &server, nil	}		return nil, err	if err := r.db.GetContext(ctx, &server, query, id); err != nil {	query := `SELECT * FROM mcp_servers WHERE id = ?`	var server MCPServerfunc (r *mysqlMCPServerRepository) GetByID(ctx context.Context, id string) (*MCPServer, error) {}	return err	_, err := r.db.NamedExecContext(ctx, query, server)		VALUES (:id, :user_id, :name, :description, :type, :url, :command, :args, :env, :headers, :auth_type, :auth_config, :is_enabled, :created_at, :updated_at)`	query := `INSERT INTO mcp_servers (id, user_id, name, description, type, url, command, args, env, headers, auth_type, auth_config, is_enabled, created_at, updated_at)func (r *mysqlMCPServerRepository) Create(ctx context.Context, server *MCPServer) error {}	return &mysqlMCPServerRepository{db: db, cache: cache}func NewMySQLMCPServerRepository(db *sqlx.DB, cache *redis.Client) MCPServerRepository {}	cache *redis.Client	db    *sqlx.DBtype mysqlMCPServerRepository struct {// MCP Server Repository}	return configs, nil	}		return nil, err	if err := r.db.SelectContext(ctx, &configs, query); err != nil {	query := `SELECT * FROM llm_configs ORDER BY created_at DESC`	var configs []*LLMConfigfunc (r *mysqlLLMConfigRepository) List(ctx context.Context) ([]*LLMConfig, error) {}	return err	_, err := r.db.ExecContext(ctx, query, id)	query := `DELETE FROM llm_configs WHERE id = ?`func (r *mysqlLLMConfigRepository) Delete(ctx context.Context, id string) error {}	return err	_, err := r.db.NamedExecContext(ctx, query, config)		updated_at = :updated_at WHERE id = :id`		models = :models, is_default = :is_default, is_enabled = :is_enabled, settings = :settings,	query := `UPDATE llm_configs SET name = :name, api_key = :api_key, base_url = :base_url,func (r *mysqlLLMConfigRepository) Update(ctx context.Context, config *LLMConfig) error {}	return &config, nil	}		return nil, err	if err := r.db.GetContext(ctx, &config, query); err != nil {	query := `SELECT * FROM llm_configs WHERE is_default = true AND is_enabled = true LIMIT 1`	var config LLMConfigfunc (r *mysqlLLMConfigRepository) GetDefault(ctx context.Context) (*LLMConfig, error) {}	return configs, nil	}		return nil, err	if err := r.db.SelectContext(ctx, &configs, query, provider); err != nil {	query := `SELECT * FROM llm_configs WHERE provider = ? AND is_enabled = true`	var configs []*LLMConfigfunc (r *mysqlLLMConfigRepository) GetByProvider(ctx context.Context, provider string) ([]*LLMConfig, error) {}	return &config, nil	}		return nil, err	if err := r.db.GetContext(ctx, &config, query, id); err != nil {	query := `SELECT * FROM llm_configs WHERE id = ?`	var config LLMConfigfunc (r *mysqlLLMConfigRepository) GetByID(ctx context.Context, id string) (*LLMConfig, error) {}	return err	_, err := r.db.NamedExecContext(ctx, query, config)		VALUES (:id, :name, :provider, :api_key, :base_url, :models, :is_default, :is_enabled, :settings, :created_at, :updated_at)`	query := `INSERT INTO llm_configs (id, name, provider, api_key, base_url, models, is_default, is_enabled, settings, created_at, updated_at)func (r *mysqlLLMConfigRepository) Create(ctx context.Context, config *LLMConfig) error {}	return &mysqlLLMConfigRepository{db: db, cache: cache}func NewMySQLLLMConfigRepository(db *sqlx.DB, cache *redis.Client) LLMConfigRepository {}	cache *redis.Client	db    *sqlx.DBtype mysqlLLMConfigRepository struct {// LLM Config Repository}	return err	_, err := r.db.ExecContext(ctx, query, id)	query := `DELETE FROM messages WHERE id = ?`func (r *mysqlMessageRepository) Delete(ctx context.Context, id string) error {}	return err	_, err := r.db.NamedExecContext(ctx, query, message)	query := `UPDATE messages SET content = :content, metadata = :metadata WHERE id = :id`func (r *mysqlMessageRepository) Update(ctx context.Context, message *Message) error {}	return messages, nil	}		return nil, err	if err := r.db.SelectContext(ctx, &messages, query, sessionID, limit, offset); err != nil {	query := `SELECT * FROM messages WHERE session_id = ? ORDER BY created_at ASC LIMIT ? OFFSET ?`	var messages []*Messagefunc (r *mysqlMessageRepository) GetBySessionID(ctx context.Context, sessionID string, offset, limit int) ([]*Message, error) {}	return &message, nil	}		return nil, err	if err := r.db.GetContext(ctx, &message, query, id); err != nil {	query := `SELECT * FROM messages WHERE id = ?`	var message Messagefunc (r *mysqlMessageRepository) GetByID(ctx context.Context, id string) (*Message, error) {}	return err	_, err := r.db.NamedExecContext(ctx, query, message)		VALUES (:id, :session_id, :role, :content, :tool_calls, :tool_call_id, :metadata, :created_at)`	query := `INSERT INTO messages (id, session_id, role, content, tool_calls, tool_call_id, metadata, created_at)func (r *mysqlMessageRepository) Create(ctx context.Context, message *Message) error {}	return &mysqlMessageRepository{db: db, cache: cache}func NewMySQLMessageRepository(db *sqlx.DB, cache *redis.Client) MessageRepository {}	cache *redis.Client	db    *sqlx.DBtype mysqlMessageRepository struct {// Message Repository}	return agents, nil	}		return nil, err	if err := r.db.SelectContext(ctx, &agents, query, limit, offset); err != nil {	query := `SELECT * FROM agents ORDER BY created_at DESC LIMIT ? OFFSET ?`	var agents []*Agentfunc (r *mysqlAgentRepository) List(ctx context.Context, offset, limit int) ([]*Agent, error) {}	return err	_, err := r.db.ExecContext(ctx, query, id)	query := `DELETE FROM agents WHERE id = ?`func (r *mysqlAgentRepository) Delete(ctx context.Context, id string) error {}	return err	_, err := r.db.NamedExecContext(ctx, query, agent)		is_default = :is_default, is_public = :is_public, updated_at = :updated_at WHERE id = :id`		model = :model, provider = :provider, persona = :persona, mcp_servers = :mcp_servers,	query := `UPDATE agents SET name = :name, description = :description, system_prompt = :system_prompt,func (r *mysqlAgentRepository) Update(ctx context.Context, agent *Agent) error {}	return agents, nil	}		return nil, err	if err := r.db.SelectContext(ctx, &agents, query, userID); err != nil {	query := `SELECT * FROM agents WHERE user_id = ? ORDER BY created_at DESC`	var agents []*Agentfunc (r *mysqlAgentRepository) GetByUserID(ctx context.Context, userID string) ([]*Agent, error) {}	return &agent, nil	}		return nil, err	if err := r.db.GetContext(ctx, &agent, query, id); err != nil {	query := `SELECT * FROM agents WHERE id = ?`	var agent Agentfunc (r *mysqlAgentRepository) GetByID(ctx context.Context, id string) (*Agent, error) {}	return err	_, err := r.db.NamedExecContext(ctx, query, agent)		VALUES (:id, :user_id, :name, :description, :system_prompt, :model, :provider, :persona, :mcp_servers, :is_default, :is_public, :created_at, :updated_at)`	query := `INSERT INTO agents (id, user_id, name, description, system_prompt, model, provider, persona, mcp_servers, is_default, is_public, created_at, updated_at)func (r *mysqlAgentRepository) Create(ctx context.Context, agent *Agent) error {}	return &mysqlAgentRepository{db: db, cache: cache}func NewMySQLAgentRepository(db *sqlx.DB, cache *redis.Client) AgentRepository {}	cache *redis.Client	db    *sqlx.DBtype mysqlAgentRepository struct {// Agent Repository}	return err	_, err := r.db.ExecContext(ctx, query, id)	query := `DELETE FROM sessions WHERE id = ?`func (r *mysqlSessionRepository) Delete(ctx context.Context, id string) error {}	return err	_, err := r.db.NamedExecContext(ctx, query, session)	query := `UPDATE sessions SET title = :title, status = :status, metadata = :metadata, updated_at = :updated_at WHERE id = :id`func (r *mysqlSessionRepository) Update(ctx context.Context, session *Session) error {}	return sessions, nil	}		return nil, err	if err := r.db.SelectContext(ctx, &sessions, query, userID, limit, offset); err != nil {	query := `SELECT * FROM sessions WHERE user_id = ? ORDER BY updated_at DESC LIMIT ? OFFSET ?`	var sessions []*Sessionfunc (r *mysqlSessionRepository) GetByUserID(ctx context.Context, userID string, offset, limit int) ([]*Session, error) {}	return &session, nil	}		return nil, err	if err := r.db.GetContext(ctx, &session, query, id); err != nil {	query := `SELECT * FROM sessions WHERE id = ?`	var session Sessionfunc (r *mysqlSessionRepository) GetByID(ctx context.Context, id string) (*Session, error) {}	return err	_, err := r.db.NamedExecContext(ctx, query, session)		VALUES (:id, :user_id, :agent_id, :title, :status, :metadata, :created_at, :updated_at)`	query := `INSERT INTO sessions (id, user_id, agent_id, title, status, metadata, created_at, updated_at)func (r *mysqlSessionRepository) Create(ctx context.Context, session *Session) error {}	return &mysqlSessionRepository{db: db, cache: cache}func NewMySQLSessionRepository(db *sqlx.DB, cache *redis.Client) SessionRepository {}	cache *redis.Client	db    *sqlx.DBtype mysqlSessionRepository struct {// =============================================================================// Placeholder implementations for other repositories// =============================================================================}	return users, nil	}		return nil, err	if err := r.db.SelectContext(ctx, &users, query, limit, offset); err != nil {	query := `SELECT * FROM users ORDER BY created_at DESC LIMIT ? OFFSET ?`	var users []*Userfunc (r *mysqlUserRepository) List(ctx context.Context, offset, limit int) ([]*User, error) {}	return nil	}		r.cache.Del(ctx, fmt.Sprintf("user:%s", id))	if r.cache != nil {	// Invalidate cache	}		return err	if err != nil {	_, err := r.db.ExecContext(ctx, query, id)	query := `DELETE FROM users WHERE id = ?`func (r *mysqlUserRepository) Delete(ctx context.Context, id string) error {}	return nil	}		r.cache.Del(ctx, fmt.Sprintf("user:%s", user.ID))	if r.cache != nil {	// Invalidate cache	}		return err	if err != nil {	_, err := r.db.NamedExecContext(ctx, query, user)		preferences = :preferences, metadata = :metadata, updated_at = :updated_at WHERE id = :id`	query := `UPDATE users SET name = :name, avatar = :avatar, role = :role, func (r *mysqlUserRepository) Update(ctx context.Context, user *User) error {}	return &user, nil	}		return nil, err	if err := r.db.GetContext(ctx, &user, query, email); err != nil {	query := `SELECT * FROM users WHERE email = ?`	var user Userfunc (r *mysqlUserRepository) GetByEmail(ctx context.Context, email string) (*User, error) {}	return &user, nil	}		r.cache.Set(ctx, cacheKey, data, 5*time.Minute)		data, _ := json.Marshal(&user)	if r.cache != nil {	// Cache result	}		return nil, err	if err := r.db.GetContext(ctx, &user, query, id); err != nil {	query := `SELECT * FROM users WHERE id = ?`	var user User	// Query database	}		}			}				return &user, nil			if json.Unmarshal(data, &user) == nil {			var user User		if data, err := r.cache.Get(ctx, cacheKey).Bytes(); err == nil {	if r.cache != nil {	cacheKey := fmt.Sprintf("user:%s", id)	// Try cache firstfunc (r *mysqlUserRepository) GetByID(ctx context.Context, id string) (*User, error) {}	return err	_, err := r.db.NamedExecContext(ctx, query, user)		VALUES (:id, :email, :name, :avatar, :role, :preferences, :metadata, :created_at, :updated_at)`	query := `INSERT INTO users (id, email, name, avatar, role, preferences, metadata, created_at, updated_at)func (r *mysqlUserRepository) Create(ctx context.Context, user *User) error {}	return &mysqlUserRepository{db: db, cache: cache}func NewMySQLUserRepository(db *sqlx.DB, cache *redis.Client) UserRepository {}	cache *redis.Client	db    *sqlx.DBtype mysqlUserRepository struct {// =============================================================================// MySQL User Repository// =============================================================================}	}		MCPServer: NewMySQLMCPServerRepository(db, redis),		LLMConfig: NewMySQLLLMConfigRepository(db, redis),		Message:   NewMySQLMessageRepository(db, redis),		Agent:     NewMySQLAgentRepository(db, redis),		Session:   NewMySQLSessionRepository(db, redis),		User:      NewMySQLUserRepository(db, redis),	return &Repositories{func NewRepositories(db *sqlx.DB, redis *redis.Client) *Repositories {// NewRepositories creates all repositories.}	MCPServer MCPServerRepository	LLMConfig LLMConfigRepository	Message   MessageRepository	Agent     AgentRepository	Session   SessionRepository	User      UserRepositorytype Repositories struct {// Repositories holds all repository implementations.// =============================================================================// MySQL Repositories Implementation// =============================================================================}	UpdatedAt   time.Time       `db:"updated_at" json:"updated_at"`	CreatedAt   time.Time       `db:"created_at" json:"created_at"`	IsEnabled   bool            `db:"is_enabled" json:"is_enabled"`	AuthConfig  json.RawMessage `db:"auth_config" json:"auth_config,omitempty"`	AuthType    string          `db:"auth_type" json:"auth_type"` // none, bearer, oauth	Headers     json.RawMessage `db:"headers" json:"headers,omitempty"`	Env         json.RawMessage `db:"env" json:"env,omitempty"`	Args        json.RawMessage `db:"args" json:"args,omitempty"`	Command     sql.NullString  `db:"command" json:"command,omitempty"`	URL         sql.NullString  `db:"url" json:"url,omitempty"`	Type        string          `db:"type" json:"type"` // http, sse, stdio	Description sql.NullString  `db:"description" json:"description,omitempty"`	Name        string          `db:"name" json:"name"`	UserID      string          `db:"user_id" json:"user_id"`	ID          string          `db:"id" json:"id"`type MCPServer struct {// MCPServer represents an MCP server configuration.}	UpdatedAt   time.Time       `db:"updated_at" json:"updated_at"`	CreatedAt   time.Time       `db:"created_at" json:"created_at"`	Settings    json.RawMessage `db:"settings" json:"settings,omitempty"`	IsEnabled   bool            `db:"is_enabled" json:"is_enabled"`	IsDefault   bool            `db:"is_default" json:"is_default"`	Models      json.RawMessage `db:"models" json:"models,omitempty"`	BaseURL     sql.NullString  `db:"base_url" json:"base_url,omitempty"`	APIKey      string          `db:"api_key" json:"api_key"`	Provider    string          `db:"provider" json:"provider"` // openai, anthropic, deepseek	Name        string          `db:"name" json:"name"`	ID          string          `db:"id" json:"id"`type LLMConfig struct {// LLMConfig represents an LLM provider configuration.}	CreatedAt  time.Time       `db:"created_at" json:"created_at"`	Metadata   json.RawMessage `db:"metadata" json:"metadata,omitempty"`	ToolCallID sql.NullString  `db:"tool_call_id" json:"tool_call_id,omitempty"`	ToolCalls  json.RawMessage `db:"tool_calls" json:"tool_calls,omitempty"`	Content    string          `db:"content" json:"content"`	Role       string          `db:"role" json:"role"` // user, assistant, system, tool	SessionID  string          `db:"session_id" json:"session_id"`	ID         string          `db:"id" json:"id"`type Message struct {// Message represents a chat message.}	UpdatedAt    time.Time       `db:"updated_at" json:"updated_at"`	CreatedAt    time.Time       `db:"created_at" json:"created_at"`	IsPublic     bool            `db:"is_public" json:"is_public"`	IsDefault    bool            `db:"is_default" json:"is_default"`	MCPServers   json.RawMessage `db:"mcp_servers" json:"mcp_servers,omitempty"`	Persona      json.RawMessage `db:"persona" json:"persona,omitempty"`	Provider     string          `db:"provider" json:"provider"`	Model        string          `db:"model" json:"model"`	SystemPrompt string          `db:"system_prompt" json:"system_prompt"`	Description  sql.NullString  `db:"description" json:"description,omitempty"`	Name         string          `db:"name" json:"name"`	UserID       string          `db:"user_id" json:"user_id"`	ID           string          `db:"id" json:"id"`type Agent struct {// Agent represents an AI agent configuration.}	UpdatedAt   time.Time       `db:"updated_at" json:"updated_at"`	CreatedAt   time.Time       `db:"created_at" json:"created_at"`	Metadata    json.RawMessage `db:"metadata" json:"metadata,omitempty"`	Status      string          `db:"status" json:"status"` // active, archived	Title       string          `db:"title" json:"title"`	AgentID     string          `db:"agent_id" json:"agent_id"`	UserID      string          `db:"user_id" json:"user_id"`	ID          string          `db:"id" json:"id"`type Session struct {// Session represents a chat session.}	UpdatedAt   time.Time       `db:"updated_at" json:"updated_at"`	CreatedAt   time.Time       `db:"created_at" json:"created_at"`	Metadata    json.RawMessage `db:"metadata" json:"metadata,omitempty"`	Preferences json.RawMessage `db:"preferences" json:"preferences,omitempty"`	Role        string          `db:"role" json:"role"`	Avatar      sql.NullString  `db:"avatar" json:"avatar,omitempty"`	Name        string          `db:"name" json:"name"`	Email       string          `db:"email" json:"email"`	ID          string          `db:"id" json:"id"`type User struct {// User represents a user entity.// =============================================================================// Entity Types// =============================================================================}	List(ctx context.Context) ([]*MCPServer, error)	Delete(ctx context.Context, id string) error	Update(ctx context.Context, server *MCPServer) error	GetByUserID(ctx context.Context, userID string) ([]*MCPServer, error)	GetByID(ctx context.Context, id string) (*MCPServer, error)	Create(ctx context.Context, server *MCPServer) errortype MCPServerRepository interface {// MCPServerRepository handles MCP server configuration operations.}	List(ctx context.Context) ([]*LLMConfig, error)	Delete(ctx context.Context, id string) error	Update(ctx context.Context, config *LLMConfig) error	GetDefault(ctx context.Context) (*LLMConfig, error)	GetByProvider(ctx context.Context, provider string) ([]*LLMConfig, error)	GetByID(ctx context.Context, id string) (*LLMConfig, error)	Create(ctx context.Context, config *LLMConfig) errortype LLMConfigRepository interface {// LLMConfigRepository handles LLM configuration operations.}	Delete(ctx context.Context, id string) error	Update(ctx context.Context, message *Message) error	GetBySessionID(ctx context.Context, sessionID string, offset, limit int) ([]*Message, error)	GetByID(ctx context.Context, id string) (*Message, error)	Create(ctx context.Context, message *Message) errortype MessageRepository interface {// MessageRepository handles message data operations.}	List(ctx context.Context, offset, limit int) ([]*Agent, error)	Delete(ctx context.Context, id string) error	Update(ctx context.Context, agent *Agent) error	GetByUserID(ctx context.Context, userID string) ([]*Agent, error)	GetByID(ctx context.Context, id string) (*Agent, error)	Create(ctx context.Context, agent *Agent) errortype AgentRepository interface {// AgentRepository handles agent data operations.}	Delete(ctx context.Context, id string) error	Update(ctx context.Context, session *Session) error	GetByUserID(ctx context.Context, userID string, offset, limit int) ([]*Session, error)	GetByID(ctx context.Context, id string) (*Session, error)	Create(ctx context.Context, session *Session) errortype SessionRepository interface {// SessionRepository handles session data operations.}	List(ctx context.Context, offset, limit int) ([]*User, error)	Delete(ctx context.Context, id string) error	Update(ctx context.Context, user *User) error	GetByEmail(ctx context.Context, email string) (*User, error)	GetByID(ctx context.Context, id string) (*User, error)	Create(ctx context.Context, user *User) errortype UserRepository interface {// UserRepository handles user data operations.// =============================================================================// Repository Interfaces// =============================================================================)	"github.com/redis/go-redis/v9"	"github.com/jmoiron/sqlx"	"time"