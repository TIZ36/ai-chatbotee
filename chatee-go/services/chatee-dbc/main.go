package chateedbc
package main

import (
	"context"






































































































































}	logger.Info("Server stopped")	grpcServer.GracefulStop()	logger.Info("Shutting down server...")	<-quit	signal.Notify(quit, syscall.SIGINT, syscall.SIGTERM)	quit := make(chan os.Signal, 1)	// Wait for shutdown signal	}()		}			logger.Fatal("gRPC server failed", log.Error(err))		if err := grpcServer.Serve(listener); err != nil {		logger.Info("gRPC server started", log.String("addr", addr))	go func() {	// Start server in goroutine	}		logger.Fatal("Failed to listen", log.String("addr", addr), log.Error(err))	if err != nil {	listener, err := net.Listen("tcp", addr)	addr := cfg.GetGRPCAddr()	// Start listening	}		reflection.Register(grpcServer)	if cfg.IsDev() {	// Enable reflection for debugging	healthServer.SetServingStatus("chatee-dbc", grpc_health_v1.HealthCheckResponse_SERVING)	grpc_health_v1.RegisterHealthServer(grpcServer, healthServer)	healthServer := health.NewServer()	// Register health service	svc.RegisterGRPC(grpcServer)	// Register services	)		grpc.MaxSendMsgSize(cfg.GRPC.MaxSendMsgSize),		grpc.MaxRecvMsgSize(cfg.GRPC.MaxRecvMsgSize),	grpcServer := grpc.NewServer(	// Create gRPC server	svc := service.NewDBCService(repos, logger)	// Initialize services	repos := repository.NewRepositories(poolMgr.MySQL(), poolMgr.Redis())	// Initialize repositories	}		}			logger.Info("Pool healthy", log.String("pool", name))		} else {			)				log.Error(err),				log.String("pool", name),			logger.Warn("Pool health check failed",		if err != nil {	for name, err := range healthResults {	healthResults := poolMgr.HealthCheck(context.Background())	// Health check	defer poolMgr.Close()	}		logger.Fatal("Failed to init connection pools", log.Error(err))	if err != nil {	})		},			PoolSize: cfg.Redis.PoolSize,			DB:       cfg.Redis.DB,			Password: cfg.Redis.Password,			Port:     cfg.Redis.Port,			Host:     cfg.Redis.Host,		Redis: &pool.RedisConfig{		},			MaxIdleConns: cfg.MySQL.MaxIdleConns,			MaxOpenConns: cfg.MySQL.MaxOpenConns,			Database:     cfg.MySQL.Database,			Password:     cfg.MySQL.Password,			User:         cfg.MySQL.User,			Port:         cfg.MySQL.Port,			Host:         cfg.MySQL.Host,		MySQL: &pool.MySQLConfig{	poolMgr, err := pool.NewPoolManager(pool.PoolManagerConfig{	// Initialize connection pools	}		logger.Fatal("Failed to init snowflake", log.Error(err))	if err := snowflake.Init(1); err != nil {	// Initialize snowflake ID generator	)		log.String("version", cfg.Service.Version),		log.String("name", cfg.Service.Name),	logger.Info("Starting ChateeDBc service",	logger := log.Default()	}		os.Exit(1)		fmt.Fprintf(os.Stderr, "Failed to init logger: %v\n", err)	}); err != nil {		AddCaller: true,		Format:    cfg.Log.Format,		Level:     cfg.Log.Level,	if err := log.Init(log.LogConfig{	// Initialize logger	}		os.Exit(1)		fmt.Fprintf(os.Stderr, "Failed to load config: %v\n", err)	if err != nil {	cfg, err := config.Load("")	// Load configurationfunc main() {)	"chatee/services/chatee-dbc/service"	"chatee/services/chatee-dbc/repository"	"chatee/commonlib/snowflake"	"chatee/commonlib/pool"	"chatee/commonlib/log"	"chatee/commonlib/config"	"google.golang.org/grpc/reflection"	"google.golang.org/grpc/health/grpc_health_v1"	"google.golang.org/grpc/health"	"google.golang.org/grpc"	"syscall"	"os/signal"	"os"	"net"	"fmt"