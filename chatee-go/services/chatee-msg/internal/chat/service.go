package chat
package chat

import (
	"context"
	"encoding/json"
	"fmt"
	"time"
















































































































































































































































































































































































































































































































































































































































}	}		MessageRetention: 0,		TypingIndicator: true,		ReadReceipts:    true,		AllowInvites:    true,	return &ChatSettings{func defaultChatSettings() *ChatSettings {// defaultChatSettings returns default chat settings}	}		redis.SAdd(ctx, membersKey, m)	for _, m := range members {	members, _ := redis.SMembers(ctx, participantsKey).Result()	// Copy all participants to channel members	membersKey := fmt.Sprintf("channel:%s:members", channelID)	participantsKey := fmt.Sprintf("chat:%s:participants", chatID)	redis := s.cfg.Pools.GetRedis()func (s *Service) syncChannelMembers(ctx context.Context, chatID, channelID string) {// syncChannelMembers syncs channel members (all chat participants by default)}	}		redis.SAdd(ctx, userChatsKey, chat.ID)		userChatsKey := fmt.Sprintf("user:%s:chats", p.UserID)		// Add to user's chat list		redis.SAdd(ctx, participantsKey, p.UserID)	for _, p := range chat.Participants {	redis.Del(ctx, participantsKey)	// Clear and rebuild	participantsKey := fmt.Sprintf("chat:%s:participants", chat.ID)	redis := s.cfg.Pools.GetRedis()func (s *Service) syncParticipants(ctx context.Context, chat *Chat) {// syncParticipants syncs participants to Redis for fast lookup}	return &chat, nil	json.Unmarshal([]byte(settingsJSON), &chat.Settings)	json.Unmarshal([]byte(channelsJSON), &chat.Channels)	json.Unmarshal([]byte(participantsJSON), &chat.Participants)	}		return nil, fmt.Errorf("chat not found: %s", chatID)	if err != nil {	)		&chat.CreatedAt, &chat.UpdatedAt,		&chat.OwnerID, &participantsJSON, &channelsJSON, &settingsJSON,		&chat.ID, &chat.Type, &chat.Name, &chat.Description, &chat.AvatarURL,	`, chatID).Scan(		FROM chats WHERE id = ?			participants, channels, settings, created_at, updated_at		SELECT id, type, name, description, avatar_url, owner_id,	err := db.QueryRowContext(ctx, `	var participantsJSON, channelsJSON, settingsJSON string	var chat Chat	db := s.cfg.Pools.GetMySQL()func (s *Service) loadChat(ctx context.Context, chatID string) (*Chat, error) {// loadChat loads a chat from the database}	return err		chat.CreatedAt, chat.UpdatedAt)		chat.OwnerID, participantsJSON, channelsJSON, settingsJSON,	`, chat.ID, chat.Type, chat.Name, chat.Description, chat.AvatarURL,			updated_at = VALUES(updated_at)			settings = VALUES(settings),			channels = VALUES(channels),			participants = VALUES(participants),			avatar_url = VALUES(avatar_url),			description = VALUES(description),			name = VALUES(name),		ON DUPLICATE KEY UPDATE		VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)			participants, channels, settings, created_at, updated_at)		INSERT INTO chats (id, type, name, description, avatar_url, owner_id, 	_, err := db.ExecContext(ctx, `	settingsJSON, _ := json.Marshal(chat.Settings)	channelsJSON, _ := json.Marshal(chat.Channels)	participantsJSON, _ := json.Marshal(chat.Participants)	db := s.cfg.Pools.GetMySQL()func (s *Service) saveChat(ctx context.Context, chat *Chat) error {// saveChat saves a chat to the database}	return nil	}		redis.Publish(ctx, fmt.Sprintf("chat:%s:events", chatID), eventJSON)	} else {		redis.Publish(ctx, fmt.Sprintf("channel:%s:events", channelID), eventJSON)	if channelID != "" {	eventJSON, _ := json.Marshal(event)	}		"is_typing":  isTyping,		"user_id":    userID,		"channel_id": channelID,		"chat_id":    chatID,		"type":       "typing",	event := map[string]interface{}{	// Publish typing event	}		redis.SRem(ctx, key, userID)	} else {		redis.Expire(ctx, key, 5*time.Second)		redis.SAdd(ctx, key, userID)	if isTyping {	}		key = fmt.Sprintf("channel:%s:typing", channelID)	if channelID != "" {	key := fmt.Sprintf("chat:%s:typing", chatID)	redis := s.cfg.Pools.GetRedis()func (s *Service) SetTyping(ctx context.Context, chatID, channelID, userID string, isTyping bool) error {// SetTyping sets typing indicator for a user}	return s.UpdateChat(ctx, chat)	}		}			break			chat.Participants[i].LastSeenAt = time.Now()		if p.UserID == userID {	for i, p := range chat.Participants {	}		return err	if err != nil {	chat, err := s.GetChat(ctx, chatID)	// Update participant's last seen timestamp	redis.Set(ctx, lastSeenKey, lastMessageID, 0)	lastSeenKey := fmt.Sprintf("chat:%s:last_seen:%s", chatID, userID)	// Update last seen	redis := s.cfg.Pools.GetRedis()func (s *Service) MarkAsRead(ctx context.Context, chatID, userID, lastMessageID string) error {// MarkAsRead marks messages as read up to a certain point}	return chats, nil	}		chats = append(chats, chat)		}			continue		if err != nil {		chat, err := s.GetChat(ctx, chatID)	for _, chatID := range chatIDs {	chats := make([]*Chat, 0, len(chatIDs))	}		return nil, err	if err != nil {	chatIDs, err := redis.SMembers(ctx, chatsKey).Result()	chatsKey := fmt.Sprintf("user:%s:chats", userID)	// Get chat IDs from user's chat list	redis := s.cfg.Pools.GetRedis()func (s *Service) GetUserChats(ctx context.Context, userID string) ([]*Chat, error) {// GetUserChats returns all chats for a user}	return s.UpdateChat(ctx, chat)	chat.Channels = newChannels	}		newChannels = append(newChannels, c)		}			continue		if c.ID == channelID {	for _, c := range chat.Channels {	newChannels := make([]Channel, 0, len(chat.Channels))	// Find and remove channel	}		return err	if err != nil {	chat, err := s.GetChat(ctx, chatID)func (s *Service) DeleteChannel(ctx context.Context, chatID, channelID string) error {// DeleteChannel deletes a channel from a group chat}	Type        ChannelType	Description string	Name        stringtype CreateChannelRequest struct {// CreateChannelRequest represents a request to create a channel}	return &channel, nil	s.syncChannelMembers(ctx, chatID, channelID)	// Sync channel members (all chat participants by default)	}		return nil, err	if err := s.UpdateChat(ctx, chat); err != nil {	chat.Channels = append(chat.Channels, channel)	}		CreatedAt:   time.Now(),		Position:    len(chat.Channels),		Type:        req.Type,		Description: req.Description,		Name:        req.Name,		ChatID:      chatID,		ID:          channelID,	channel := Channel{	channelID := snowflake.GenerateTypedID("chn")	}		return nil, fmt.Errorf("channels only supported for group chats")	if chat.Type != ChatTypeGroup {	}		return nil, err	if err != nil {	chat, err := s.GetChat(ctx, chatID)func (s *Service) CreateChannel(ctx context.Context, chatID string, req *CreateChannelRequest) (*Channel, error) {// CreateChannel creates a new channel in a group chat}	return nil	})		Content:    fmt.Sprintf("User %s left the chat", userID),		SenderType: fanout.SenderSystem,		SenderID:   "system",		ChatID:     chatID,	s.SendMessage(ctx, &SendMessageRequest{	// Send system message	redis.SRem(ctx, participantsKey, userID)	participantsKey := fmt.Sprintf("chat:%s:participants", chatID)	redis := s.cfg.Pools.GetRedis()	// Update Redis participants set	}		return err	if err := s.UpdateChat(ctx, chat); err != nil {	chat.Participants = newParticipants	}		return fmt.Errorf("user not in chat")	if !found {	}		newParticipants = append(newParticipants, p)		}			continue			found = true		if p.UserID == userID {	for _, p := range chat.Participants {	found := false	newParticipants := make([]Participant, 0, len(chat.Participants))	// Find and remove participant	}		return err	if err != nil {	chat, err := s.GetChat(ctx, chatID)func (s *Service) RemoveParticipant(ctx context.Context, chatID, userID string) error {// RemoveParticipant removes a participant from a chat}	return nil	})		Content:    fmt.Sprintf("User %s joined the chat", userID),		SenderType: fanout.SenderSystem,		SenderID:   "system",		ChatID:     chatID,	s.SendMessage(ctx, &SendMessageRequest{	// Send system message	redis.SAdd(ctx, participantsKey, userID)	participantsKey := fmt.Sprintf("chat:%s:participants", chatID)	redis := s.cfg.Pools.GetRedis()	// Update Redis participants set	}		return err	if err := s.UpdateChat(ctx, chat); err != nil {	})		JoinedAt: time.Now(),		Role:     role,		UserID:   userID,	chat.Participants = append(chat.Participants, Participant{	// Add participant	}		}			return fmt.Errorf("user already in chat")		if p.UserID == userID {	for _, p := range chat.Participants {	// Check if already a participant	}		return err	if err != nil {	chat, err := s.GetChat(ctx, chatID)func (s *Service) AddParticipant(ctx context.Context, chatID, userID string, role ParticipantRole) error {// AddParticipant adds a participant to a chat}	return messages, nil	}		messages = append(messages, msg)		}			continue		if err != nil {		msg, err := s.cfg.Fanout.GetMessage(ctx, messageID)	for _, messageID := range messageIDs {	messages := make([]*fanout.Message, 0, len(messageIDs))	}		return nil, err	if err != nil {	messageIDs, err := redis.ZRevRange(ctx, listKey, offset, offset+limit-1).Result()	// Get message IDs in reverse chronological order	}		listKey = fmt.Sprintf("chat:%s:messages", chatID)	} else {		listKey = fmt.Sprintf("channel:%s:messages", channelID)	if channelID != "" {	var listKey string	redis := s.cfg.Pools.GetRedis()func (s *Service) GetMessages(ctx context.Context, chatID, channelID string, limit, offset int64) ([]*fanout.Message, error) {// GetMessages retrieves messages from a chat}	return msg, nil	}		return nil, fmt.Errorf("failed to fanout message: %w", err)	}); err != nil {		TargetID:   targetID,		TargetType: targetType,		Message:    msg,	if err := s.cfg.Fanout.Fanout(ctx, &fanout.FanoutRequest{	// Fanout the message	}		targetID = req.ChannelID		targetType = fanout.TargetChannel	if req.ChannelID != "" {	targetID := req.ChatID	targetType := fanout.TargetChat	// Determine target type and ID	}		Timestamp:   now,		ChannelID:   req.ChannelID,		ChatID:      req.ChatID,		Metadata:    req.Metadata,		ContentType: req.ContentType,		Content:     req.Content,		SenderType:  req.SenderType,		SenderID:    req.SenderID,		Type:        fanout.MsgTypeText,		ID:          messageID,	msg := &fanout.Message{	now := time.Now()	messageID := snowflake.GenerateTypedID("msg")func (s *Service) SendMessage(ctx context.Context, req *SendMessageRequest) (*fanout.Message, error) {// SendMessage sends a message to a chat}	Metadata    map[string]interface{}	ContentType string	Content     string	SenderType  fanout.SenderType	SenderID    string	ChannelID   string // Optional, for group chats	ChatID      stringtype SendMessageRequest struct {// SendMessageRequest represents a request to send a message}	return nil	redis.Del(ctx, cacheKey)	cacheKey := fmt.Sprintf("chat:%s:data", chat.ID)	redis := s.cfg.Pools.GetRedis()	// Invalidate cache	}		return err	if err := s.saveChat(ctx, chat); err != nil {	chat.UpdatedAt = time.Now()func (s *Service) UpdateChat(ctx context.Context, chat *Chat) error {// UpdateChat updates a chat}	return chat, nil	}		redis.Set(ctx, cacheKey, data, 30*time.Minute)	if data, err := json.Marshal(chat); err == nil {	// Cache the result	}		return nil, err	if err != nil {	chat, err := s.loadChat(ctx, chatID)	// Load from database	}		}			return &chat, nil		if json.Unmarshal([]byte(cached), &chat) == nil {		var chat Chat	if err == nil {	cached, err := redis.Get(ctx, cacheKey).Result()	cacheKey := fmt.Sprintf("chat:%s:data", chatID)	// Try cache first	redis := s.cfg.Pools.GetRedis()func (s *Service) GetChat(ctx context.Context, chatID string) (*Chat, error) {// GetChat retrieves a chat by ID}	return chat, nil	s.syncParticipants(ctx, chat)	// Add participants to Redis set for quick lookup	}		return nil, fmt.Errorf("failed to save chat: %w", err)	if err := s.saveChat(ctx, chat); err != nil {	// Save to database	}		}			},				CreatedAt:   now,				Position:    0,				Type:        ChannelTypeText,				Description: "General discussion",				Name:        "general",				ChatID:      chatID,				ID:          channelID,			{		chat.Channels = []Channel{		channelID := snowflake.GenerateTypedID("chn")	if req.Type == ChatTypeGroup {	// For group chats, create a default general channel	}		UpdatedAt:    now,		CreatedAt:    now,		Settings:     defaultChatSettings(),		Participants: participants,		OwnerID:      req.OwnerID,		Description:  req.Description,		Name:         req.Name,		Type:         req.Type,		ID:           chatID,	chat := &Chat{	}		}			})				JoinedAt: now,				Role:     RoleMember,				UserID:   userID,			participants = append(participants, Participant{		if userID != req.OwnerID {	for _, userID := range req.Participants {	// Add other participants	})		JoinedAt: now,		Role:     RoleOwner,		UserID:   req.OwnerID,	participants = append(participants, Participant{	// Add owner		participants := make([]Participant, 0, len(req.Participants)+1)	// Build participants list	now := time.Now()	chatID := snowflake.GenerateTypedID("cht")func (s *Service) CreateChat(ctx context.Context, req *CreateChatRequest) (*Chat, error) {// CreateChat creates a new chat}	AIAgentID    string   // For AI chats	Participants []string // User IDs	OwnerID      string	Description  string	Name         string	Type         ChatTypetype CreateChatRequest struct {// CreateChatRequest represents a request to create a chat}	MessageRetention int // Days, 0 = forever	TypingIndicator bool	ReadReceipts    bool	AllowInvites    booltype ChatSettings struct {// ChatSettings represents chat settings)	ChannelTypeAI    ChannelType = "ai" // Channel with AI agent	ChannelTypeVoice ChannelType = "voice"	ChannelTypeText  ChannelType = "text"const (type ChannelType string// ChannelType represents the type of channel}	CreatedAt   time.Time	Position    int	Type        ChannelType	Description string	Name        string	ChatID      string	ID          stringtype Channel struct {// Channel represents a channel within a group chat)	RoleMember  ParticipantRole = "member"	RoleAdmin   ParticipantRole = "admin"	RoleOwner   ParticipantRole = "owner"const (type ParticipantRole string// ParticipantRole represents a participant's role}	LastSeenAt time.Time	JoinedAt  time.Time	Muted     bool	Nickname  string	Role      ParticipantRole	UserID    stringtype Participant struct {// Participant represents a chat participant)	ChatTypeAI    ChatType = "ai"    // AI chat (user + AI agent)	ChatTypeGroup ChatType = "group" // Group chat (multiple users)	ChatTypeDM    ChatType = "dm"    // Direct message (2 users)const (type ChatType string// ChatType represents the type of chat}	UpdatedAt    time.Time	CreatedAt    time.Time	Settings     *ChatSettings	Channels     []Channel	Participants []Participant	OwnerID      string	AvatarURL    string	Description  string	Name         string	Type         ChatType	ID           stringtype Chat struct {// Chat represents a chat (private DM or group)}	_ = svc	_ = server	// Will register proto-generated service interfacefunc RegisterGRPC(server *grpc.Server, svc *Service) {// RegisterGRPC registers the service with a gRPC server}	return &Service{cfg: cfg}func NewService(cfg Config) *Service {// NewService creates a new chat service}	cfg Configtype Service struct {// Service implements chat-based messaging (private/group with channels)}	Logger log.Logger	Fanout *fanout.Service	Pools  *pool.PoolManagertype Config struct {// Config holds the chat service configuration)	"google.golang.org/grpc"	"chatee-go/services/chatee-msg/internal/fanout"	"chatee-go/commonlib/snowflake"	"chatee-go/commonlib/pool"	"chatee-go/commonlib/log"