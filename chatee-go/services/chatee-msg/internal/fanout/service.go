package fanout
package fanout

import (
	"context"
	"encoding/json"




























































































































































































































































































































































































}	return s[:maxLen-3] + "..."	}		return s	if len(s) <= maxLen {func truncateString(s string, maxLen int) string {// Helper function to truncate strings}	return &msg, nil		}		return nil, err	if err := json.Unmarshal([]byte(msgJSON), &msg); err != nil {	var msg Message		}		return nil, fmt.Errorf("message not found: %s", messageID)	if err != nil {	msgJSON, err := redis.Get(ctx, msgKey).Result()	msgKey := fmt.Sprintf("msg:%s", messageID)		redis := s.cfg.Pools.GetRedis()func (s *Service) GetMessage(ctx context.Context, messageID string) (*Message, error) {// GetMessage retrieves a message by ID}	return count, nil	}		return 0, nil // Return 0 if key doesn't exist	if err != nil {	count, err := redis.Get(ctx, unreadKey).Int64()	unreadKey := fmt.Sprintf("inbox:%s:unread", userID)		redis := s.cfg.Pools.GetRedis()func (s *Service) GetUnreadCount(ctx context.Context, userID string) (int64, error) {// GetUnreadCount returns the unread message count for a user}	return nil		}		redis.DecrBy(ctx, unreadKey, int64(len(messageIDs)))		unreadKey := fmt.Sprintf("inbox:%s:unread", userID)	if len(messageIDs) > 0 {	// Decrease unread count		redis := s.cfg.Pools.GetRedis()func (s *Service) MarkAsRead(ctx context.Context, userID string, messageIDs []string) error {// MarkAsRead marks messages as read in a user's inbox}	return result, nil		}		result = append(result, entry)		}			continue		if err := json.Unmarshal([]byte(entryJSON), &entry); err != nil {		var entry InboxEntry	for _, entryJSON := range entries {	result := make([]InboxEntry, 0, len(entries))		}		return nil, err	if err != nil {	entries, err := redis.ZRevRange(ctx, inboxKey, offset, offset+limit-1).Result()	// Get entries in reverse chronological order		inboxKey := fmt.Sprintf("inbox:%s", userID)		redis := s.cfg.Pools.GetRedis()func (s *Service) GetInbox(ctx context.Context, userID string, limit, offset int64) ([]InboxEntry, error) {// GetInbox retrieves a user's inbox}	}		redis.Publish(ctx, fmt.Sprintf("channel:%s:events", msg.ChannelID), notifJSON)	if msg.ChannelID != "" {	}		redis.Publish(ctx, fmt.Sprintf("chat:%s:events", msg.ChatID), notifJSON)	if msg.ChatID != "" {	}		redis.Publish(ctx, fmt.Sprintf("thread:%s:events", msg.ThreadID), notifJSON)	if msg.ThreadID != "" {	// Also publish to target channel for any subscribers		}		redis.Publish(ctx, channel, notifJSON)		channel := fmt.Sprintf("notify:%s", recipientID)	for _, recipientID := range recipients {	// Publish to each recipient's channel		notifJSON, _ := json.Marshal(notification)		}		"recipients": recipients,		"timestamp":  msg.Timestamp.Unix(),		"preview":    truncateString(msg.Content, 50),		"channel_id": msg.ChannelID,		"chat_id":    msg.ChatID,		"thread_id":  msg.ThreadID,		"sender_id":  msg.SenderID,		"message_id": msg.ID,		"type":       "new_message",	notification := map[string]interface{}{		redis := s.cfg.Pools.GetRedis()func (s *Service) publishNotification(ctx context.Context, msg *Message, recipients []string) {// publishNotification publishes a real-time notification}	Read      bool      `json:"read"`	Timestamp time.Time `json:"timestamp"`	Preview   string    `json:"preview"`	SenderID  string    `json:"sender_id"`	ChannelID string    `json:"channel_id,omitempty"`	ChatID    string    `json:"chat_id,omitempty"`	ThreadID  string    `json:"thread_id,omitempty"`	MessageID string    `json:"message_id"`type InboxEntry struct {// InboxEntry represents an entry in a user's inbox}	return nil		redis.Incr(ctx, unreadKey)	unreadKey := fmt.Sprintf("inbox:%s:unread", userID)	// Increment unread count		redis.ZRemRangeByRank(ctx, inboxKey, 0, -1001)	// Trim inbox to keep last 1000 messages		})		Member: string(entryJSON),		Score:  float64(msg.Timestamp.UnixNano()),	redis.ZAdd(ctx, inboxKey, redis.Z{		}		return err	if err != nil {	entryJSON, err := json.Marshal(entry)		}		Read:      false,		Timestamp: msg.Timestamp,		Preview:   truncateString(msg.Content, 100),		SenderID:  msg.SenderID,		ChannelID: msg.ChannelID,		ChatID:    msg.ChatID,		ThreadID:  msg.ThreadID,		MessageID: msg.ID,	entry := InboxEntry{	// Create inbox entry with source info		inboxKey := fmt.Sprintf("inbox:%s", userID)	// Add to user's inbox (sorted set by timestamp)		redis := s.cfg.Pools.GetRedis()func (s *Service) deliverToInbox(ctx context.Context, userID string, msg *Message) error {// deliverToInbox delivers a message to a user's inbox}	}		return nil, fmt.Errorf("unknown target type: %s", targetType)	default:				return []string{targetID}, nil		// Direct message to specific user	case TargetUser:				return result, nil		}			}				result = append(result, m)			if m != senderID {		for _, m := range members {		result := make([]string, 0, len(members))		}			return nil, err		if err != nil {		members, err := redis.SMembers(ctx, key).Result()		key := fmt.Sprintf("channel:%s:members", targetID)		// Get channel members	case TargetChannel:				return result, nil		}			}				result = append(result, p)			if p != senderID {		for _, p := range participants {		result := make([]string, 0, len(participants))		// Exclude sender		}			return nil, err		if err != nil {		participants, err := redis.SMembers(ctx, key).Result()		key := fmt.Sprintf("chat:%s:participants", targetID)		// Get chat participants	case TargetChat:				return followers, nil		}			return nil, err		if err != nil {		followers, err := redis.SMembers(ctx, key).Result()		key := fmt.Sprintf("thread:%s:followers", targetID)		// Get thread followers/subscribers	case TargetThread:	switch targetType {		redis := s.cfg.Pools.GetRedis()func (s *Service) getRecipients(ctx context.Context, targetType TargetType, targetID, senderID string) ([]string, error) {// getRecipients returns the list of recipient user IDs for a target}	return nil		}		})			Member: msg.ID,			Score:  float64(msg.Timestamp.UnixNano()),		redis.ZAdd(ctx, listKey, redis.Z{	if listKey != "" {		}		listKey = fmt.Sprintf("chat:%s:messages", msg.ChatID)	} else if msg.ChatID != "" {		listKey = fmt.Sprintf("channel:%s:messages", msg.ChannelID)	} else if msg.ChannelID != "" {		listKey = fmt.Sprintf("thread:%s:messages", msg.ThreadID)	if msg.ThreadID != "" {	var listKey string	// Add to target's message list		redis.Set(ctx, msgKey, msgJSON, 7*24*time.Hour)	msgKey := fmt.Sprintf("msg:%s", msg.ID)	// Store message data		}		return err	if err != nil {	msgJSON, err := json.Marshal(msg)		redis := s.cfg.Pools.GetRedis()	// For now, also store in Redis for quick access		// This allows efficient range scans for recent messages	// Store in HBase with row key: {target_id}#{reverse_timestamp}#{message_id}func (s *Service) storeMessage(ctx context.Context, msg *Message) error {// storeMessage stores the message in HBase}	return nil	s.publishNotification(ctx, req.Message, recipients)	// Publish real-time notification via Redis Pub/Sub	}		}			// Continue with other recipients				"error", err)				"message_id", req.Message.ID,				"recipient", recipientID,			s.cfg.Logger.Error("Failed to deliver to inbox",		if err := s.deliverToInbox(ctx, recipientID, req.Message); err != nil {	for _, recipientID := range recipients {	// Fanout to each recipient's inbox	}		return fmt.Errorf("failed to get recipients: %w", err)	if err != nil {	recipients, err := s.getRecipients(ctx, req.TargetType, req.TargetID, req.Message.SenderID)	// Get recipients based on target type	}		return fmt.Errorf("failed to store message: %w", err)	if err := s.storeMessage(ctx, req.Message); err != nil {	// Store the original message	}		req.Message.Timestamp = time.Now()	if req.Message.Timestamp.IsZero() {	}		req.Message.ID = snowflake.GenerateTypedID("msg")	if req.Message.ID == "" {	// Generate message ID if not setfunc (s *Service) Fanout(ctx context.Context, req *FanoutRequest) error {// Fanout distributes a message to all recipients)	TargetUser    TargetType = "user"	TargetChannel TargetType = "channel"	TargetChat    TargetType = "chat"	TargetThread  TargetType = "thread"const (type TargetType string// TargetType represents the target type for fanout}	TargetID   string	TargetType TargetType	Message    *Messagetype FanoutRequest struct {// FanoutRequest represents a fanout request)	SenderSystem SenderType = "system"	SenderAgent  SenderType = "agent"	SenderUser   SenderType = "user"const (type SenderType string// SenderType represents the type of sender)	MsgTypeThinking   MessageType = "thinking"	MsgTypeToolResult MessageType = "tool_result"	MsgTypeToolCall   MessageType = "tool_call"	MsgTypeSystem     MessageType = "system"	MsgTypeFile       MessageType = "file"	MsgTypeImage      MessageType = "image"	MsgTypeText       MessageType = "text"const (type MessageType string// MessageType represents the type of message}	Recipients  []string // Specific recipients for DM/mentions	ChannelID   string   // For channel messages	ChatID      string   // For chat messages	ThreadID    string   // For thread messages	// Target information		Timestamp   time.Time	Metadata    map[string]interface{}	ContentType string	Content     string	SenderType  SenderType // user, agent, system	SenderID    string	Type        MessageType	ID          stringtype Message struct {// Message represents a message to be fanned out}	_ = svc	_ = server	// Will register proto-generated service interfacefunc RegisterGRPC(server *grpc.Server, svc *Service) {// RegisterGRPC registers the service with a gRPC server}	return &Service{cfg: cfg}func NewService(cfg Config) *Service {// NewService creates a new fanout service}	cfg Configtype Service struct {// Service implements message fanout (write-based distribution)}	Logger log.Logger	Pools  *pool.PoolManagertype Config struct {// Config holds the fanout service configuration)	"google.golang.org/grpc"	"chatee-go/commonlib/snowflake"	"chatee-go/commonlib/pool"	"chatee-go/commonlib/log"	"time"	"fmt"