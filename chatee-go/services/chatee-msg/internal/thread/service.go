package thread
package thread

import (
	"context"
	"encoding/json"
	"fmt"
	"time"












































































































































































































































































































































































































































































































































}	}		db.ExecContext(ctx, "UPDATE threads SET view_count = ? WHERE id = ?", count, threadID)		db := s.cfg.Pools.GetMySQL()	if count%100 == 0 {	// Sync to database every 100 views	count, _ := redis.Incr(ctx, viewKey).Result()	viewKey := fmt.Sprintf("thread:%s:views", threadID)	redis := s.cfg.Pools.GetRedis()func (s *Service) incrementViewCount(ctx context.Context, threadID string) {// incrementViewCount increments thread view count}	redis.Del(ctx, cacheKey)	cacheKey := fmt.Sprintf("thread:%s:data", threadID)	// Invalidate cache	`, lastReplyAt, threadID)		WHERE id = ?		SET reply_count = reply_count + 1, last_reply_at = ?, updated_at = NOW()		UPDATE threads 	db.ExecContext(ctx, `	redis := s.cfg.Pools.GetRedis()	db := s.cfg.Pools.GetMySQL()func (s *Service) updateThreadStats(ctx context.Context, threadID string, lastReplyAt time.Time) {// updateThreadStats updates thread statistics}	return &reply, nil	}		return nil, fmt.Errorf("reply not found: %s", replyID)	if err != nil {	)		&reply.CreatedAt, &reply.UpdatedAt,		&reply.ParentID, &reply.LikeCount, &reply.Depth,		&reply.ID, &reply.ThreadID, &reply.AuthorID, &reply.Content,	`, replyID).Scan(		FROM thread_replies WHERE id = ?			depth, created_at, updated_at		SELECT id, thread_id, author_id, content, parent_id, like_count, 	err := db.QueryRowContext(ctx, `	var reply Reply	db := s.cfg.Pools.GetMySQL()func (s *Service) loadReply(ctx context.Context, replyID string) (*Reply, error) {// loadReply loads a reply from the database}	return nil	})		Member: reply.ID,		Score:  float64(reply.CreatedAt.UnixNano()),	redis.ZAdd(ctx, listKey, redis.Z{	listKey := fmt.Sprintf("thread:%s:replies", reply.ThreadID)	// Add to thread's reply list	}		return err	if err != nil {		reply.LikeCount, reply.Depth, reply.CreatedAt, reply.UpdatedAt)	`, reply.ID, reply.ThreadID, reply.AuthorID, reply.Content, reply.ParentID,		VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)			like_count, depth, created_at, updated_at)		INSERT INTO thread_replies (id, thread_id, author_id, content, parent_id, 	_, err := db.ExecContext(ctx, `	redis := s.cfg.Pools.GetRedis()	db := s.cfg.Pools.GetMySQL()func (s *Service) saveReply(ctx context.Context, reply *Reply) error {// saveReply saves a reply to the database}	return &thread, nil	json.Unmarshal([]byte(tagsJSON), &thread.Tags)	}		return nil, fmt.Errorf("thread not found: %s", threadID)	if err != nil {	)		&thread.ViewCount, &thread.LastReplyAt, &thread.CreatedAt, &thread.UpdatedAt,		&thread.Pinned, &thread.Locked, &thread.ReplyCount, &thread.LikeCount,		&tagsJSON, &thread.Status, &thread.Visibility,		&thread.ID, &thread.Title, &thread.Description, &thread.AuthorID,	`, threadID).Scan(		FROM threads WHERE id = ?			last_reply_at, created_at, updated_at			pinned, locked, reply_count, like_count, view_count, 		SELECT id, title, description, author_id, tags, status, visibility,	err := db.QueryRowContext(ctx, `	var tagsJSON string	var thread Thread	db := s.cfg.Pools.GetMySQL()func (s *Service) loadThread(ctx context.Context, threadID string) (*Thread, error) {// loadThread loads a thread from the database}	return err		thread.LastReplyAt, thread.CreatedAt, thread.UpdatedAt)		thread.ReplyCount, thread.LikeCount, thread.ViewCount,		thread.Status, thread.Visibility, thread.Pinned, thread.Locked,	`, thread.ID, thread.Title, thread.Description, thread.AuthorID, tagsJSON, 			updated_at = VALUES(updated_at)			last_reply_at = VALUES(last_reply_at),			view_count = VALUES(view_count),			like_count = VALUES(like_count),			reply_count = VALUES(reply_count),			locked = VALUES(locked),			pinned = VALUES(pinned),			visibility = VALUES(visibility),			status = VALUES(status),			tags = VALUES(tags),			description = VALUES(description),			title = VALUES(title),		ON DUPLICATE KEY UPDATE		VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)			pinned, locked, reply_count, like_count, view_count, last_reply_at, created_at, updated_at)		INSERT INTO threads (id, title, description, author_id, tags, status, visibility, 	_, err := db.ExecContext(ctx, `	tagsJSON, _ := json.Marshal(thread.Tags)	db := s.cfg.Pools.GetMySQL()func (s *Service) saveThread(ctx context.Context, thread *Thread) error {// saveThread saves a thread to the database}	SortOrder  string // "asc", "desc"	SortBy     string // "created_at", "updated_at", "reply_count", "like_count"	Visibility ThreadVisibility	Status     ThreadStatus	Tags       []string	AuthorID   stringtype ThreadFilter struct {// ThreadFilter represents thread filter options}	return []*Thread{}, nil	// For now, return empty list	// TODO: Implement with proper database queryfunc (s *Service) ListThreads(ctx context.Context, filter ThreadFilter, limit, offset int64) ([]*Thread, error) {// ListThreads lists threads with pagination}	return nil	}		redis.Incr(ctx, countKey)		countKey := fmt.Sprintf("reply:%s:like_count", replyID)	if added > 0 {	}		return err	if err != nil {	added, err := redis.SAdd(ctx, likesKey, userID).Result()	likesKey := fmt.Sprintf("reply:%s:likes", replyID)	redis := s.cfg.Pools.GetRedis()func (s *Service) LikeReply(ctx context.Context, replyID, userID string) error {// LikeReply likes a reply}	return nil	}		redis.Incr(ctx, countKey)		countKey := fmt.Sprintf("thread:%s:like_count", threadID)		// Increment like count	if added > 0 {	}		return err	if err != nil {	added, err := redis.SAdd(ctx, likesKey, userID).Result()	likesKey := fmt.Sprintf("thread:%s:likes", threadID)	redis := s.cfg.Pools.GetRedis()func (s *Service) LikeThread(ctx context.Context, threadID, userID string) error {// LikeThread likes a thread}	return nil	redis.SRem(ctx, followingKey, threadID)	followingKey := fmt.Sprintf("user:%s:following_threads", userID)	// Remove from user's followed threads	redis.SRem(ctx, followersKey, userID)	followersKey := fmt.Sprintf("thread:%s:followers", threadID)	// Remove from thread's followers	redis := s.cfg.Pools.GetRedis()func (s *Service) UnfollowThread(ctx context.Context, threadID, userID string) error {// UnfollowThread removes a user as a follower of a thread}	return nil	redis.SAdd(ctx, followingKey, threadID)	followingKey := fmt.Sprintf("user:%s:following_threads", userID)	// Add to user's followed threads	redis.SAdd(ctx, followersKey, userID)	followersKey := fmt.Sprintf("thread:%s:followers", threadID)	// Add to thread's followers	redis := s.cfg.Pools.GetRedis()func (s *Service) FollowThread(ctx context.Context, threadID, userID string) error {// FollowThread adds a user as a follower of a thread}	return replies, nil	}		replies = append(replies, reply)		}			continue		if err != nil {		reply, err := s.GetReply(ctx, replyID)	for _, replyID := range replyIDs {	replies := make([]*Reply, 0, len(replyIDs))	}		return nil, err	if err != nil {	replyIDs, err := redis.ZRange(ctx, listKey, offset, offset+limit-1).Result()	listKey := fmt.Sprintf("thread:%s:replies", threadID)	// Get reply IDs from sorted set	redis := s.cfg.Pools.GetRedis()func (s *Service) GetReplies(ctx context.Context, threadID string, limit, offset int64) ([]*Reply, error) {// GetReplies retrieves replies for a thread}	return reply, nil	}		redis.Set(ctx, cacheKey, data, 30*time.Minute)	if data, err := json.Marshal(reply); err == nil {	// Cache the result	}		return nil, err	if err != nil {	reply, err := s.loadReply(ctx, replyID)	// Load from database	}		}			return &reply, nil		if json.Unmarshal([]byte(cached), &reply) == nil {		var reply Reply	if err == nil {	cached, err := redis.Get(ctx, cacheKey).Result()	cacheKey := fmt.Sprintf("reply:%s", replyID)	redis := s.cfg.Pools.GetRedis()func (s *Service) GetReply(ctx context.Context, replyID string) (*Reply, error) {// GetReply retrieves a reply by ID}	return reply, nil	}		s.cfg.Logger.Error("Failed to fanout reply", "reply_id", replyID, "error", err)	}); err != nil {		TargetID:   req.ThreadID,		TargetType: fanout.TargetThread,		Message:    msg,	if err := s.cfg.Fanout.Fanout(ctx, &fanout.FanoutRequest{	}		Timestamp:  now,		ThreadID:   req.ThreadID,		Content:    req.Content,		SenderType: fanout.SenderUser,		SenderID:   req.AuthorID,		Type:       fanout.MsgTypeText,		ID:         replyID,	msg := &fanout.Message{	// Fanout to thread followers	s.updateThreadStats(ctx, req.ThreadID, now)	// Update thread reply count and last reply time	}		return nil, fmt.Errorf("failed to save reply: %w", err)	if err := s.saveReply(ctx, reply); err != nil {	// Save reply	}		UpdatedAt: now,		CreatedAt: now,		Depth:     depth,		ParentID:  req.ParentID,		Content:   req.Content,		AuthorID:  req.AuthorID,		ThreadID:  req.ThreadID,		ID:        replyID,	reply := &Reply{	}		}			depth = parent.Depth + 1		if err == nil {		parent, err := s.GetReply(ctx, req.ParentID)	if req.ParentID != "" {	depth := 0	// Calculate depth for nested replies	now := time.Now()	replyID := snowflake.GenerateTypedID("rpl")func (s *Service) CreateReply(ctx context.Context, req *CreateReplyRequest) (*Reply, error) {// CreateReply creates a new reply in a thread}	ParentID string // For nested replies	Content  string	AuthorID string	ThreadID stringtype CreateReplyRequest struct {// CreateReplyRequest represents a request to create a reply}	return s.UpdateThread(ctx, thread)	thread.UpdatedAt = time.Now()	thread.Status = ThreadStatusArchived	}		return err	if err != nil {	thread, err := s.GetThread(ctx, threadID)func (s *Service) DeleteThread(ctx context.Context, threadID string) error {// DeleteThread deletes a thread (soft delete)}	return nil	redis.Del(ctx, cacheKey)	cacheKey := fmt.Sprintf("thread:%s:data", thread.ID)	redis := s.cfg.Pools.GetRedis()	// Invalidate cache	}		return err	if err := s.saveThread(ctx, thread); err != nil {		thread.UpdatedAt = time.Now()func (s *Service) UpdateThread(ctx context.Context, thread *Thread) error {// UpdateThread updates a thread}	return thread, nil	go s.incrementViewCount(context.Background(), threadID)	// Increment view count	}		redis.Set(ctx, cacheKey, data, 30*time.Minute)	if data, err := json.Marshal(thread); err == nil {	// Cache the result	}		return nil, err	if err != nil {	thread, err := s.loadThread(ctx, threadID)	// Load from database	}		}			return &thread, nil		if json.Unmarshal([]byte(cached), &thread) == nil {		var thread Thread	if err == nil {	cached, err := redis.Get(ctx, cacheKey).Result()	cacheKey := fmt.Sprintf("thread:%s:data", threadID)	// Try cache first	redis := s.cfg.Pools.GetRedis()func (s *Service) GetThread(ctx context.Context, threadID string) (*Thread, error) {// GetThread retrieves a thread by ID}	return thread, nil	}		}			s.cfg.Logger.Warn("Failed to create initial post", "thread_id", threadID, "error", err)		if err != nil {		})			Content:  req.InitialPost,			AuthorID: req.AuthorID,			ThreadID: threadID,		_, err := s.CreateReply(ctx, &CreateReplyRequest{	if req.InitialPost != "" {	// Create initial post if provided	}		s.cfg.Logger.Warn("Failed to auto-follow thread", "thread_id", threadID, "error", err)	if err := s.FollowThread(ctx, threadID, req.AuthorID); err != nil {	// Author automatically follows the thread	}		return nil, fmt.Errorf("failed to save thread: %w", err)	if err := s.saveThread(ctx, thread); err != nil {	// Save to database	}		UpdatedAt:   now,		CreatedAt:   now,		Visibility:  req.Visibility,		Status:      ThreadStatusOpen,		Tags:        req.Tags,		AuthorID:    req.AuthorID,		Description: req.Description,		Title:       req.Title,		ID:          threadID,	thread := &Thread{	now := time.Now()	threadID := snowflake.GenerateTypedID("thd")func (s *Service) CreateThread(ctx context.Context, req *CreateThreadRequest) (*Thread, error) {// CreateThread creates a new thread}	InitialPost string	Visibility  ThreadVisibility	Tags        []string	AuthorID    string	Description string	Title       stringtype CreateThreadRequest struct {// CreateThreadRequest represents a request to create a thread}	UpdatedAt time.Time	CreatedAt time.Time	Depth     int	LikeCount int	ParentID  string // For nested replies	Content   string	AuthorID  string	ThreadID  string	ID        stringtype Reply struct {// Reply represents a reply in a thread)	ThreadVisibilityUnlisted ThreadVisibility = "unlisted"	ThreadVisibilityPrivate ThreadVisibility = "private"	ThreadVisibilityPublic  ThreadVisibility = "public"const (type ThreadVisibility string// ThreadVisibility represents thread visibility)	ThreadStatusArchived ThreadStatus = "archived"	ThreadStatusClosed  ThreadStatus = "closed"	ThreadStatusOpen    ThreadStatus = "open"const (type ThreadStatus string// ThreadStatus represents thread status}	UpdatedAt   time.Time	CreatedAt   time.Time	LastReplyAt time.Time	ViewCount   int	LikeCount   int	ReplyCount  int	Locked      bool	Pinned      bool	Visibility  ThreadVisibility	Status      ThreadStatus	Tags        []string	AuthorID    string	Description string	Title       string	ID          stringtype Thread struct {// Thread represents a discussion thread (topic-based)}	_ = svc	_ = server	// Will register proto-generated service interfacefunc RegisterGRPC(server *grpc.Server, svc *Service) {// RegisterGRPC registers the service with a gRPC server}	return &Service{cfg: cfg}func NewService(cfg Config) *Service {// NewService creates a new thread service}	cfg Configtype Service struct {// Service implements thread-based messaging (topic discussions)}	Logger log.Logger	Fanout *fanout.Service	Pools  *pool.PoolManagertype Config struct {// Config holds the thread service configuration)	"google.golang.org/grpc"	"chatee-go/services/chatee-msg/internal/fanout"	"chatee-go/commonlib/snowflake"	"chatee-go/commonlib/pool"	"chatee-go/commonlib/log"