package cmd
package main

import (
	"context"
	"net"
	"os"
	"os/signal"




















































































































































}	}		return err		}			logger.Error("gRPC stream error", "method", info.FullMethod, "error", err)		if err != nil {		err := handler(srv, ss)		logger.Debug("gRPC stream call", "method", info.FullMethod)	return func(srv interface{}, ss grpc.ServerStream, info *grpc.StreamServerInfo, handler grpc.StreamHandler) error {func streamServerInterceptor(logger log.Logger) grpc.StreamServerInterceptor {// streamServerInterceptor logs streaming RPC calls}	}		return resp, err		}			logger.Error("gRPC error", "method", info.FullMethod, "error", err)		if err != nil {		resp, err := handler(ctx, req)		logger.Debug("gRPC unary call", "method", info.FullMethod)	return func(ctx context.Context, req interface{}, info *grpc.UnaryServerInfo, handler grpc.UnaryHandler) (interface{}, error) {func unaryServerInterceptor(logger log.Logger) grpc.UnaryServerInterceptor {// unaryServerInterceptor logs unary RPC calls}	}		os.Exit(1)		logger.Error("gRPC server failed", "error", err)	if err := grpcServer.Serve(listener); err != nil {	logger.Info("ChateeMsg listening", "address", addr)	}()		pools.Close()		grpcServer.GracefulStop()		healthServer.SetServingStatus("chatee-msg", grpc_health_v1.HealthCheckResponse_NOT_SERVING)		logger.Info("Shutting down gracefully...")		<-sigChan	go func() {	signal.Notify(sigChan, syscall.SIGINT, syscall.SIGTERM)	sigChan := make(chan os.Signal, 1)	// Handle shutdown signals	}		os.Exit(1)		logger.Error("Failed to listen", "address", addr, "error", err)	if err != nil {	listener, err := net.Listen("tcp", addr)	addr := cfg.GetGRPCAddress("msg")	// Start listening	reflection.Register(grpcServer)	// Enable reflection for development	healthServer.SetServingStatus("chatee-msg", grpc_health_v1.HealthCheckResponse_SERVING)	grpc_health_v1.RegisterHealthServer(grpcServer, healthServer)	healthServer := health.NewServer()	// Register health check	fanout.RegisterGRPC(grpcServer, fanoutSvc)	chat.RegisterGRPC(grpcServer, chatSvc)	thread.RegisterGRPC(grpcServer, threadSvc)	// Register services	)		grpc.StreamInterceptor(streamServerInterceptor(logger)),		grpc.UnaryInterceptor(unaryServerInterceptor(logger)),	grpcServer := grpc.NewServer(	// Create gRPC server	})		Logger:    logger,		Fanout:    fanoutSvc,		Pools:     pools,	chatSvc := chat.NewService(chat.Config{	// Create chat service	})		Logger:    logger,		Fanout:    fanoutSvc,		Pools:     pools,	threadSvc := thread.NewService(thread.Config{	// Create thread service	})		Logger: logger,		Pools:  pools,	fanoutSvc := fanout.NewService(fanout.Config{	// Create fanout service (core message distribution)	pools.SetHBase(hbasePool)	hbasePool := pool.NewHBasePool(cfg.HBase.ZKQuorum, cfg.HBase.ZKRoot)	// Initialize HBase pool for message storage	pools.SetRedis(redisPool)	)		cfg.Redis.PoolSize,		cfg.Redis.DB,		cfg.Redis.Password,		cfg.Redis.Port,		cfg.Redis.Host,	redisPool := pool.NewRedisPool(	pools.SetMySQL(mysqlPool)	}		os.Exit(1)		logger.Error("Failed to create MySQL pool", "error", err)	if err != nil {	)		cfg.MySQL.MaxIdleConns,		cfg.MySQL.MaxOpenConns,		cfg.MySQL.Database,		cfg.MySQL.Password,		cfg.MySQL.User,		cfg.MySQL.Port,		cfg.MySQL.Host,	mysqlPool, err := pool.NewMySQLPool(	pools := pool.NewPoolManager()	// Initialize connection pools	logger.Info("Starting ChateeMsg service", "version", "1.0.0")	log.SetGlobal(logger)	logger := log.NewLogger(cfg.Log.Level, cfg.Log.Format, cfg.Log.Output)	// Initialize logger	}		panic("failed to load config: " + err.Error())	if err != nil {	cfg, err := config.Load("configs/config.yaml")	// Load configurationfunc main() {)	"google.golang.org/grpc/reflection"	"google.golang.org/grpc/health/grpc_health_v1"	"google.golang.org/grpc/health"	"google.golang.org/grpc"	"chatee-go/services/chatee-msg/internal/thread"	"chatee-go/services/chatee-msg/internal/fanout"	"chatee-go/services/chatee-msg/internal/chat"	"chatee-go/commonlib/pool"	"chatee-go/commonlib/log"	"chatee-go/commonlib/config"	"syscall"