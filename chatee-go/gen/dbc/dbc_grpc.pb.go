// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.6.0
// - protoc             v5.28.3
// source: dbc/dbc.proto

package dbc

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	UserService_CreateUser_FullMethodName     = "/chatee.dbc.UserService/CreateUser"
	UserService_GetUser_FullMethodName        = "/chatee.dbc.UserService/GetUser"
	UserService_GetUserByEmail_FullMethodName = "/chatee.dbc.UserService/GetUserByEmail"
	UserService_UpdateUser_FullMethodName     = "/chatee.dbc.UserService/UpdateUser"
	UserService_DeleteUser_FullMethodName     = "/chatee.dbc.UserService/DeleteUser"
	UserService_ListUsers_FullMethodName      = "/chatee.dbc.UserService/ListUsers"
)

// UserServiceClient is the client API for UserService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type UserServiceClient interface {
	CreateUser(ctx context.Context, in *CreateUserRequest, opts ...grpc.CallOption) (*User, error)
	GetUser(ctx context.Context, in *GetUserRequest, opts ...grpc.CallOption) (*User, error)
	GetUserByEmail(ctx context.Context, in *GetUserByEmailRequest, opts ...grpc.CallOption) (*User, error)
	UpdateUser(ctx context.Context, in *UpdateUserRequest, opts ...grpc.CallOption) (*User, error)
	DeleteUser(ctx context.Context, in *DeleteUserRequest, opts ...grpc.CallOption) (*DeleteUserResponse, error)
	ListUsers(ctx context.Context, in *ListUsersRequest, opts ...grpc.CallOption) (*ListUsersResponse, error)
}

type userServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewUserServiceClient(cc grpc.ClientConnInterface) UserServiceClient {
	return &userServiceClient{cc}
}

func (c *userServiceClient) CreateUser(ctx context.Context, in *CreateUserRequest, opts ...grpc.CallOption) (*User, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(User)
	err := c.cc.Invoke(ctx, UserService_CreateUser_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userServiceClient) GetUser(ctx context.Context, in *GetUserRequest, opts ...grpc.CallOption) (*User, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(User)
	err := c.cc.Invoke(ctx, UserService_GetUser_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userServiceClient) GetUserByEmail(ctx context.Context, in *GetUserByEmailRequest, opts ...grpc.CallOption) (*User, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(User)
	err := c.cc.Invoke(ctx, UserService_GetUserByEmail_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userServiceClient) UpdateUser(ctx context.Context, in *UpdateUserRequest, opts ...grpc.CallOption) (*User, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(User)
	err := c.cc.Invoke(ctx, UserService_UpdateUser_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userServiceClient) DeleteUser(ctx context.Context, in *DeleteUserRequest, opts ...grpc.CallOption) (*DeleteUserResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeleteUserResponse)
	err := c.cc.Invoke(ctx, UserService_DeleteUser_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userServiceClient) ListUsers(ctx context.Context, in *ListUsersRequest, opts ...grpc.CallOption) (*ListUsersResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListUsersResponse)
	err := c.cc.Invoke(ctx, UserService_ListUsers_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// UserServiceServer is the server API for UserService service.
// All implementations must embed UnimplementedUserServiceServer
// for forward compatibility.
type UserServiceServer interface {
	CreateUser(context.Context, *CreateUserRequest) (*User, error)
	GetUser(context.Context, *GetUserRequest) (*User, error)
	GetUserByEmail(context.Context, *GetUserByEmailRequest) (*User, error)
	UpdateUser(context.Context, *UpdateUserRequest) (*User, error)
	DeleteUser(context.Context, *DeleteUserRequest) (*DeleteUserResponse, error)
	ListUsers(context.Context, *ListUsersRequest) (*ListUsersResponse, error)
	mustEmbedUnimplementedUserServiceServer()
}

// UnimplementedUserServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedUserServiceServer struct{}

func (UnimplementedUserServiceServer) CreateUser(context.Context, *CreateUserRequest) (*User, error) {
	return nil, status.Error(codes.Unimplemented, "method CreateUser not implemented")
}
func (UnimplementedUserServiceServer) GetUser(context.Context, *GetUserRequest) (*User, error) {
	return nil, status.Error(codes.Unimplemented, "method GetUser not implemented")
}
func (UnimplementedUserServiceServer) GetUserByEmail(context.Context, *GetUserByEmailRequest) (*User, error) {
	return nil, status.Error(codes.Unimplemented, "method GetUserByEmail not implemented")
}
func (UnimplementedUserServiceServer) UpdateUser(context.Context, *UpdateUserRequest) (*User, error) {
	return nil, status.Error(codes.Unimplemented, "method UpdateUser not implemented")
}
func (UnimplementedUserServiceServer) DeleteUser(context.Context, *DeleteUserRequest) (*DeleteUserResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method DeleteUser not implemented")
}
func (UnimplementedUserServiceServer) ListUsers(context.Context, *ListUsersRequest) (*ListUsersResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ListUsers not implemented")
}
func (UnimplementedUserServiceServer) mustEmbedUnimplementedUserServiceServer() {}
func (UnimplementedUserServiceServer) testEmbeddedByValue()                     {}

// UnsafeUserServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to UserServiceServer will
// result in compilation errors.
type UnsafeUserServiceServer interface {
	mustEmbedUnimplementedUserServiceServer()
}

func RegisterUserServiceServer(s grpc.ServiceRegistrar, srv UserServiceServer) {
	// If the following call panics, it indicates UnimplementedUserServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&UserService_ServiceDesc, srv)
}

func _UserService_CreateUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateUserRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServiceServer).CreateUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserService_CreateUser_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServiceServer).CreateUser(ctx, req.(*CreateUserRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserService_GetUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetUserRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServiceServer).GetUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserService_GetUser_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServiceServer).GetUser(ctx, req.(*GetUserRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserService_GetUserByEmail_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetUserByEmailRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServiceServer).GetUserByEmail(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserService_GetUserByEmail_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServiceServer).GetUserByEmail(ctx, req.(*GetUserByEmailRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserService_UpdateUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateUserRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServiceServer).UpdateUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserService_UpdateUser_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServiceServer).UpdateUser(ctx, req.(*UpdateUserRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserService_DeleteUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteUserRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServiceServer).DeleteUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserService_DeleteUser_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServiceServer).DeleteUser(ctx, req.(*DeleteUserRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserService_ListUsers_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListUsersRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServiceServer).ListUsers(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserService_ListUsers_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServiceServer).ListUsers(ctx, req.(*ListUsersRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// UserService_ServiceDesc is the grpc.ServiceDesc for UserService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var UserService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "chatee.dbc.UserService",
	HandlerType: (*UserServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateUser",
			Handler:    _UserService_CreateUser_Handler,
		},
		{
			MethodName: "GetUser",
			Handler:    _UserService_GetUser_Handler,
		},
		{
			MethodName: "GetUserByEmail",
			Handler:    _UserService_GetUserByEmail_Handler,
		},
		{
			MethodName: "UpdateUser",
			Handler:    _UserService_UpdateUser_Handler,
		},
		{
			MethodName: "DeleteUser",
			Handler:    _UserService_DeleteUser_Handler,
		},
		{
			MethodName: "ListUsers",
			Handler:    _UserService_ListUsers_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "dbc/dbc.proto",
}

const (
	SessionService_CreateSession_FullMethodName     = "/chatee.dbc.SessionService/CreateSession"
	SessionService_GetSession_FullMethodName        = "/chatee.dbc.SessionService/GetSession"
	SessionService_GetSessionsByUser_FullMethodName = "/chatee.dbc.SessionService/GetSessionsByUser"
	SessionService_UpdateSession_FullMethodName     = "/chatee.dbc.SessionService/UpdateSession"
	SessionService_DeleteSession_FullMethodName     = "/chatee.dbc.SessionService/DeleteSession"
)

// SessionServiceClient is the client API for SessionService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type SessionServiceClient interface {
	CreateSession(ctx context.Context, in *CreateSessionRequest, opts ...grpc.CallOption) (*Session, error)
	GetSession(ctx context.Context, in *GetSessionRequest, opts ...grpc.CallOption) (*Session, error)
	GetSessionsByUser(ctx context.Context, in *GetSessionsByUserRequest, opts ...grpc.CallOption) (*GetSessionsByUserResponse, error)
	UpdateSession(ctx context.Context, in *UpdateSessionRequest, opts ...grpc.CallOption) (*Session, error)
	DeleteSession(ctx context.Context, in *DeleteSessionRequest, opts ...grpc.CallOption) (*DeleteSessionResponse, error)
}

type sessionServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewSessionServiceClient(cc grpc.ClientConnInterface) SessionServiceClient {
	return &sessionServiceClient{cc}
}

func (c *sessionServiceClient) CreateSession(ctx context.Context, in *CreateSessionRequest, opts ...grpc.CallOption) (*Session, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Session)
	err := c.cc.Invoke(ctx, SessionService_CreateSession_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sessionServiceClient) GetSession(ctx context.Context, in *GetSessionRequest, opts ...grpc.CallOption) (*Session, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Session)
	err := c.cc.Invoke(ctx, SessionService_GetSession_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sessionServiceClient) GetSessionsByUser(ctx context.Context, in *GetSessionsByUserRequest, opts ...grpc.CallOption) (*GetSessionsByUserResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetSessionsByUserResponse)
	err := c.cc.Invoke(ctx, SessionService_GetSessionsByUser_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sessionServiceClient) UpdateSession(ctx context.Context, in *UpdateSessionRequest, opts ...grpc.CallOption) (*Session, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Session)
	err := c.cc.Invoke(ctx, SessionService_UpdateSession_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sessionServiceClient) DeleteSession(ctx context.Context, in *DeleteSessionRequest, opts ...grpc.CallOption) (*DeleteSessionResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeleteSessionResponse)
	err := c.cc.Invoke(ctx, SessionService_DeleteSession_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// SessionServiceServer is the server API for SessionService service.
// All implementations must embed UnimplementedSessionServiceServer
// for forward compatibility.
type SessionServiceServer interface {
	CreateSession(context.Context, *CreateSessionRequest) (*Session, error)
	GetSession(context.Context, *GetSessionRequest) (*Session, error)
	GetSessionsByUser(context.Context, *GetSessionsByUserRequest) (*GetSessionsByUserResponse, error)
	UpdateSession(context.Context, *UpdateSessionRequest) (*Session, error)
	DeleteSession(context.Context, *DeleteSessionRequest) (*DeleteSessionResponse, error)
	mustEmbedUnimplementedSessionServiceServer()
}

// UnimplementedSessionServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedSessionServiceServer struct{}

func (UnimplementedSessionServiceServer) CreateSession(context.Context, *CreateSessionRequest) (*Session, error) {
	return nil, status.Error(codes.Unimplemented, "method CreateSession not implemented")
}
func (UnimplementedSessionServiceServer) GetSession(context.Context, *GetSessionRequest) (*Session, error) {
	return nil, status.Error(codes.Unimplemented, "method GetSession not implemented")
}
func (UnimplementedSessionServiceServer) GetSessionsByUser(context.Context, *GetSessionsByUserRequest) (*GetSessionsByUserResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetSessionsByUser not implemented")
}
func (UnimplementedSessionServiceServer) UpdateSession(context.Context, *UpdateSessionRequest) (*Session, error) {
	return nil, status.Error(codes.Unimplemented, "method UpdateSession not implemented")
}
func (UnimplementedSessionServiceServer) DeleteSession(context.Context, *DeleteSessionRequest) (*DeleteSessionResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method DeleteSession not implemented")
}
func (UnimplementedSessionServiceServer) mustEmbedUnimplementedSessionServiceServer() {}
func (UnimplementedSessionServiceServer) testEmbeddedByValue()                        {}

// UnsafeSessionServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to SessionServiceServer will
// result in compilation errors.
type UnsafeSessionServiceServer interface {
	mustEmbedUnimplementedSessionServiceServer()
}

func RegisterSessionServiceServer(s grpc.ServiceRegistrar, srv SessionServiceServer) {
	// If the following call panics, it indicates UnimplementedSessionServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&SessionService_ServiceDesc, srv)
}

func _SessionService_CreateSession_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateSessionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SessionServiceServer).CreateSession(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SessionService_CreateSession_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SessionServiceServer).CreateSession(ctx, req.(*CreateSessionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SessionService_GetSession_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetSessionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SessionServiceServer).GetSession(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SessionService_GetSession_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SessionServiceServer).GetSession(ctx, req.(*GetSessionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SessionService_GetSessionsByUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetSessionsByUserRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SessionServiceServer).GetSessionsByUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SessionService_GetSessionsByUser_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SessionServiceServer).GetSessionsByUser(ctx, req.(*GetSessionsByUserRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SessionService_UpdateSession_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateSessionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SessionServiceServer).UpdateSession(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SessionService_UpdateSession_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SessionServiceServer).UpdateSession(ctx, req.(*UpdateSessionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SessionService_DeleteSession_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteSessionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SessionServiceServer).DeleteSession(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SessionService_DeleteSession_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SessionServiceServer).DeleteSession(ctx, req.(*DeleteSessionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// SessionService_ServiceDesc is the grpc.ServiceDesc for SessionService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var SessionService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "chatee.dbc.SessionService",
	HandlerType: (*SessionServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateSession",
			Handler:    _SessionService_CreateSession_Handler,
		},
		{
			MethodName: "GetSession",
			Handler:    _SessionService_GetSession_Handler,
		},
		{
			MethodName: "GetSessionsByUser",
			Handler:    _SessionService_GetSessionsByUser_Handler,
		},
		{
			MethodName: "UpdateSession",
			Handler:    _SessionService_UpdateSession_Handler,
		},
		{
			MethodName: "DeleteSession",
			Handler:    _SessionService_DeleteSession_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "dbc/dbc.proto",
}

const (
	AgentService_CreateAgent_FullMethodName     = "/chatee.dbc.AgentService/CreateAgent"
	AgentService_GetAgent_FullMethodName        = "/chatee.dbc.AgentService/GetAgent"
	AgentService_GetAgentsByUser_FullMethodName = "/chatee.dbc.AgentService/GetAgentsByUser"
	AgentService_ListAgents_FullMethodName      = "/chatee.dbc.AgentService/ListAgents"
	AgentService_UpdateAgent_FullMethodName     = "/chatee.dbc.AgentService/UpdateAgent"
	AgentService_DeleteAgent_FullMethodName     = "/chatee.dbc.AgentService/DeleteAgent"
)

// AgentServiceClient is the client API for AgentService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type AgentServiceClient interface {
	CreateAgent(ctx context.Context, in *CreateAgentRequest, opts ...grpc.CallOption) (*Agent, error)
	GetAgent(ctx context.Context, in *GetAgentRequest, opts ...grpc.CallOption) (*Agent, error)
	GetAgentsByUser(ctx context.Context, in *GetAgentsByUserRequest, opts ...grpc.CallOption) (*GetAgentsByUserResponse, error)
	ListAgents(ctx context.Context, in *ListAgentsRequest, opts ...grpc.CallOption) (*ListAgentsResponse, error)
	UpdateAgent(ctx context.Context, in *UpdateAgentRequest, opts ...grpc.CallOption) (*Agent, error)
	DeleteAgent(ctx context.Context, in *DeleteAgentRequest, opts ...grpc.CallOption) (*DeleteAgentResponse, error)
}

type agentServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewAgentServiceClient(cc grpc.ClientConnInterface) AgentServiceClient {
	return &agentServiceClient{cc}
}

func (c *agentServiceClient) CreateAgent(ctx context.Context, in *CreateAgentRequest, opts ...grpc.CallOption) (*Agent, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Agent)
	err := c.cc.Invoke(ctx, AgentService_CreateAgent_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *agentServiceClient) GetAgent(ctx context.Context, in *GetAgentRequest, opts ...grpc.CallOption) (*Agent, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Agent)
	err := c.cc.Invoke(ctx, AgentService_GetAgent_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *agentServiceClient) GetAgentsByUser(ctx context.Context, in *GetAgentsByUserRequest, opts ...grpc.CallOption) (*GetAgentsByUserResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetAgentsByUserResponse)
	err := c.cc.Invoke(ctx, AgentService_GetAgentsByUser_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *agentServiceClient) ListAgents(ctx context.Context, in *ListAgentsRequest, opts ...grpc.CallOption) (*ListAgentsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListAgentsResponse)
	err := c.cc.Invoke(ctx, AgentService_ListAgents_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *agentServiceClient) UpdateAgent(ctx context.Context, in *UpdateAgentRequest, opts ...grpc.CallOption) (*Agent, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Agent)
	err := c.cc.Invoke(ctx, AgentService_UpdateAgent_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *agentServiceClient) DeleteAgent(ctx context.Context, in *DeleteAgentRequest, opts ...grpc.CallOption) (*DeleteAgentResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeleteAgentResponse)
	err := c.cc.Invoke(ctx, AgentService_DeleteAgent_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// AgentServiceServer is the server API for AgentService service.
// All implementations must embed UnimplementedAgentServiceServer
// for forward compatibility.
type AgentServiceServer interface {
	CreateAgent(context.Context, *CreateAgentRequest) (*Agent, error)
	GetAgent(context.Context, *GetAgentRequest) (*Agent, error)
	GetAgentsByUser(context.Context, *GetAgentsByUserRequest) (*GetAgentsByUserResponse, error)
	ListAgents(context.Context, *ListAgentsRequest) (*ListAgentsResponse, error)
	UpdateAgent(context.Context, *UpdateAgentRequest) (*Agent, error)
	DeleteAgent(context.Context, *DeleteAgentRequest) (*DeleteAgentResponse, error)
	mustEmbedUnimplementedAgentServiceServer()
}

// UnimplementedAgentServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedAgentServiceServer struct{}

func (UnimplementedAgentServiceServer) CreateAgent(context.Context, *CreateAgentRequest) (*Agent, error) {
	return nil, status.Error(codes.Unimplemented, "method CreateAgent not implemented")
}
func (UnimplementedAgentServiceServer) GetAgent(context.Context, *GetAgentRequest) (*Agent, error) {
	return nil, status.Error(codes.Unimplemented, "method GetAgent not implemented")
}
func (UnimplementedAgentServiceServer) GetAgentsByUser(context.Context, *GetAgentsByUserRequest) (*GetAgentsByUserResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetAgentsByUser not implemented")
}
func (UnimplementedAgentServiceServer) ListAgents(context.Context, *ListAgentsRequest) (*ListAgentsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ListAgents not implemented")
}
func (UnimplementedAgentServiceServer) UpdateAgent(context.Context, *UpdateAgentRequest) (*Agent, error) {
	return nil, status.Error(codes.Unimplemented, "method UpdateAgent not implemented")
}
func (UnimplementedAgentServiceServer) DeleteAgent(context.Context, *DeleteAgentRequest) (*DeleteAgentResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method DeleteAgent not implemented")
}
func (UnimplementedAgentServiceServer) mustEmbedUnimplementedAgentServiceServer() {}
func (UnimplementedAgentServiceServer) testEmbeddedByValue()                      {}

// UnsafeAgentServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to AgentServiceServer will
// result in compilation errors.
type UnsafeAgentServiceServer interface {
	mustEmbedUnimplementedAgentServiceServer()
}

func RegisterAgentServiceServer(s grpc.ServiceRegistrar, srv AgentServiceServer) {
	// If the following call panics, it indicates UnimplementedAgentServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&AgentService_ServiceDesc, srv)
}

func _AgentService_CreateAgent_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateAgentRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AgentServiceServer).CreateAgent(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AgentService_CreateAgent_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AgentServiceServer).CreateAgent(ctx, req.(*CreateAgentRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AgentService_GetAgent_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetAgentRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AgentServiceServer).GetAgent(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AgentService_GetAgent_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AgentServiceServer).GetAgent(ctx, req.(*GetAgentRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AgentService_GetAgentsByUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetAgentsByUserRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AgentServiceServer).GetAgentsByUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AgentService_GetAgentsByUser_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AgentServiceServer).GetAgentsByUser(ctx, req.(*GetAgentsByUserRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AgentService_ListAgents_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListAgentsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AgentServiceServer).ListAgents(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AgentService_ListAgents_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AgentServiceServer).ListAgents(ctx, req.(*ListAgentsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AgentService_UpdateAgent_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateAgentRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AgentServiceServer).UpdateAgent(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AgentService_UpdateAgent_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AgentServiceServer).UpdateAgent(ctx, req.(*UpdateAgentRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AgentService_DeleteAgent_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteAgentRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AgentServiceServer).DeleteAgent(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AgentService_DeleteAgent_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AgentServiceServer).DeleteAgent(ctx, req.(*DeleteAgentRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// AgentService_ServiceDesc is the grpc.ServiceDesc for AgentService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var AgentService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "chatee.dbc.AgentService",
	HandlerType: (*AgentServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateAgent",
			Handler:    _AgentService_CreateAgent_Handler,
		},
		{
			MethodName: "GetAgent",
			Handler:    _AgentService_GetAgent_Handler,
		},
		{
			MethodName: "GetAgentsByUser",
			Handler:    _AgentService_GetAgentsByUser_Handler,
		},
		{
			MethodName: "ListAgents",
			Handler:    _AgentService_ListAgents_Handler,
		},
		{
			MethodName: "UpdateAgent",
			Handler:    _AgentService_UpdateAgent_Handler,
		},
		{
			MethodName: "DeleteAgent",
			Handler:    _AgentService_DeleteAgent_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "dbc/dbc.proto",
}

const (
	MessageService_CreateMessage_FullMethodName        = "/chatee.dbc.MessageService/CreateMessage"
	MessageService_GetMessage_FullMethodName           = "/chatee.dbc.MessageService/GetMessage"
	MessageService_GetMessagesBySession_FullMethodName = "/chatee.dbc.MessageService/GetMessagesBySession"
	MessageService_UpdateMessage_FullMethodName        = "/chatee.dbc.MessageService/UpdateMessage"
	MessageService_DeleteMessage_FullMethodName        = "/chatee.dbc.MessageService/DeleteMessage"
)

// MessageServiceClient is the client API for MessageService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type MessageServiceClient interface {
	CreateMessage(ctx context.Context, in *CreateMessageRequest, opts ...grpc.CallOption) (*Message, error)
	GetMessage(ctx context.Context, in *GetMessageRequest, opts ...grpc.CallOption) (*Message, error)
	GetMessagesBySession(ctx context.Context, in *GetMessagesBySessionRequest, opts ...grpc.CallOption) (*GetMessagesBySessionResponse, error)
	UpdateMessage(ctx context.Context, in *UpdateMessageRequest, opts ...grpc.CallOption) (*Message, error)
	DeleteMessage(ctx context.Context, in *DeleteMessageRequest, opts ...grpc.CallOption) (*DeleteMessageResponse, error)
}

type messageServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewMessageServiceClient(cc grpc.ClientConnInterface) MessageServiceClient {
	return &messageServiceClient{cc}
}

func (c *messageServiceClient) CreateMessage(ctx context.Context, in *CreateMessageRequest, opts ...grpc.CallOption) (*Message, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Message)
	err := c.cc.Invoke(ctx, MessageService_CreateMessage_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *messageServiceClient) GetMessage(ctx context.Context, in *GetMessageRequest, opts ...grpc.CallOption) (*Message, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Message)
	err := c.cc.Invoke(ctx, MessageService_GetMessage_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *messageServiceClient) GetMessagesBySession(ctx context.Context, in *GetMessagesBySessionRequest, opts ...grpc.CallOption) (*GetMessagesBySessionResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetMessagesBySessionResponse)
	err := c.cc.Invoke(ctx, MessageService_GetMessagesBySession_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *messageServiceClient) UpdateMessage(ctx context.Context, in *UpdateMessageRequest, opts ...grpc.CallOption) (*Message, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Message)
	err := c.cc.Invoke(ctx, MessageService_UpdateMessage_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *messageServiceClient) DeleteMessage(ctx context.Context, in *DeleteMessageRequest, opts ...grpc.CallOption) (*DeleteMessageResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeleteMessageResponse)
	err := c.cc.Invoke(ctx, MessageService_DeleteMessage_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// MessageServiceServer is the server API for MessageService service.
// All implementations must embed UnimplementedMessageServiceServer
// for forward compatibility.
type MessageServiceServer interface {
	CreateMessage(context.Context, *CreateMessageRequest) (*Message, error)
	GetMessage(context.Context, *GetMessageRequest) (*Message, error)
	GetMessagesBySession(context.Context, *GetMessagesBySessionRequest) (*GetMessagesBySessionResponse, error)
	UpdateMessage(context.Context, *UpdateMessageRequest) (*Message, error)
	DeleteMessage(context.Context, *DeleteMessageRequest) (*DeleteMessageResponse, error)
	mustEmbedUnimplementedMessageServiceServer()
}

// UnimplementedMessageServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedMessageServiceServer struct{}

func (UnimplementedMessageServiceServer) CreateMessage(context.Context, *CreateMessageRequest) (*Message, error) {
	return nil, status.Error(codes.Unimplemented, "method CreateMessage not implemented")
}
func (UnimplementedMessageServiceServer) GetMessage(context.Context, *GetMessageRequest) (*Message, error) {
	return nil, status.Error(codes.Unimplemented, "method GetMessage not implemented")
}
func (UnimplementedMessageServiceServer) GetMessagesBySession(context.Context, *GetMessagesBySessionRequest) (*GetMessagesBySessionResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetMessagesBySession not implemented")
}
func (UnimplementedMessageServiceServer) UpdateMessage(context.Context, *UpdateMessageRequest) (*Message, error) {
	return nil, status.Error(codes.Unimplemented, "method UpdateMessage not implemented")
}
func (UnimplementedMessageServiceServer) DeleteMessage(context.Context, *DeleteMessageRequest) (*DeleteMessageResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method DeleteMessage not implemented")
}
func (UnimplementedMessageServiceServer) mustEmbedUnimplementedMessageServiceServer() {}
func (UnimplementedMessageServiceServer) testEmbeddedByValue()                        {}

// UnsafeMessageServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to MessageServiceServer will
// result in compilation errors.
type UnsafeMessageServiceServer interface {
	mustEmbedUnimplementedMessageServiceServer()
}

func RegisterMessageServiceServer(s grpc.ServiceRegistrar, srv MessageServiceServer) {
	// If the following call panics, it indicates UnimplementedMessageServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&MessageService_ServiceDesc, srv)
}

func _MessageService_CreateMessage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateMessageRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MessageServiceServer).CreateMessage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MessageService_CreateMessage_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MessageServiceServer).CreateMessage(ctx, req.(*CreateMessageRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MessageService_GetMessage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetMessageRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MessageServiceServer).GetMessage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MessageService_GetMessage_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MessageServiceServer).GetMessage(ctx, req.(*GetMessageRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MessageService_GetMessagesBySession_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetMessagesBySessionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MessageServiceServer).GetMessagesBySession(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MessageService_GetMessagesBySession_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MessageServiceServer).GetMessagesBySession(ctx, req.(*GetMessagesBySessionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MessageService_UpdateMessage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateMessageRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MessageServiceServer).UpdateMessage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MessageService_UpdateMessage_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MessageServiceServer).UpdateMessage(ctx, req.(*UpdateMessageRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MessageService_DeleteMessage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteMessageRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MessageServiceServer).DeleteMessage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MessageService_DeleteMessage_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MessageServiceServer).DeleteMessage(ctx, req.(*DeleteMessageRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// MessageService_ServiceDesc is the grpc.ServiceDesc for MessageService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var MessageService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "chatee.dbc.MessageService",
	HandlerType: (*MessageServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateMessage",
			Handler:    _MessageService_CreateMessage_Handler,
		},
		{
			MethodName: "GetMessage",
			Handler:    _MessageService_GetMessage_Handler,
		},
		{
			MethodName: "GetMessagesBySession",
			Handler:    _MessageService_GetMessagesBySession_Handler,
		},
		{
			MethodName: "UpdateMessage",
			Handler:    _MessageService_UpdateMessage_Handler,
		},
		{
			MethodName: "DeleteMessage",
			Handler:    _MessageService_DeleteMessage_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "dbc/dbc.proto",
}

const (
	LLMConfigService_CreateLLMConfig_FullMethodName         = "/chatee.dbc.LLMConfigService/CreateLLMConfig"
	LLMConfigService_GetLLMConfig_FullMethodName            = "/chatee.dbc.LLMConfigService/GetLLMConfig"
	LLMConfigService_GetDefaultLLMConfig_FullMethodName     = "/chatee.dbc.LLMConfigService/GetDefaultLLMConfig"
	LLMConfigService_GetLLMConfigsByProvider_FullMethodName = "/chatee.dbc.LLMConfigService/GetLLMConfigsByProvider"
	LLMConfigService_ListLLMConfigs_FullMethodName          = "/chatee.dbc.LLMConfigService/ListLLMConfigs"
	LLMConfigService_UpdateLLMConfig_FullMethodName         = "/chatee.dbc.LLMConfigService/UpdateLLMConfig"
	LLMConfigService_DeleteLLMConfig_FullMethodName         = "/chatee.dbc.LLMConfigService/DeleteLLMConfig"
)

// LLMConfigServiceClient is the client API for LLMConfigService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type LLMConfigServiceClient interface {
	CreateLLMConfig(ctx context.Context, in *CreateLLMConfigRequest, opts ...grpc.CallOption) (*LLMConfig, error)
	GetLLMConfig(ctx context.Context, in *GetLLMConfigRequest, opts ...grpc.CallOption) (*LLMConfig, error)
	GetDefaultLLMConfig(ctx context.Context, in *GetDefaultLLMConfigRequest, opts ...grpc.CallOption) (*LLMConfig, error)
	GetLLMConfigsByProvider(ctx context.Context, in *GetLLMConfigsByProviderRequest, opts ...grpc.CallOption) (*GetLLMConfigsByProviderResponse, error)
	ListLLMConfigs(ctx context.Context, in *ListLLMConfigsRequest, opts ...grpc.CallOption) (*ListLLMConfigsResponse, error)
	UpdateLLMConfig(ctx context.Context, in *UpdateLLMConfigRequest, opts ...grpc.CallOption) (*LLMConfig, error)
	DeleteLLMConfig(ctx context.Context, in *DeleteLLMConfigRequest, opts ...grpc.CallOption) (*DeleteLLMConfigResponse, error)
}

type lLMConfigServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewLLMConfigServiceClient(cc grpc.ClientConnInterface) LLMConfigServiceClient {
	return &lLMConfigServiceClient{cc}
}

func (c *lLMConfigServiceClient) CreateLLMConfig(ctx context.Context, in *CreateLLMConfigRequest, opts ...grpc.CallOption) (*LLMConfig, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(LLMConfig)
	err := c.cc.Invoke(ctx, LLMConfigService_CreateLLMConfig_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *lLMConfigServiceClient) GetLLMConfig(ctx context.Context, in *GetLLMConfigRequest, opts ...grpc.CallOption) (*LLMConfig, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(LLMConfig)
	err := c.cc.Invoke(ctx, LLMConfigService_GetLLMConfig_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *lLMConfigServiceClient) GetDefaultLLMConfig(ctx context.Context, in *GetDefaultLLMConfigRequest, opts ...grpc.CallOption) (*LLMConfig, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(LLMConfig)
	err := c.cc.Invoke(ctx, LLMConfigService_GetDefaultLLMConfig_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *lLMConfigServiceClient) GetLLMConfigsByProvider(ctx context.Context, in *GetLLMConfigsByProviderRequest, opts ...grpc.CallOption) (*GetLLMConfigsByProviderResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetLLMConfigsByProviderResponse)
	err := c.cc.Invoke(ctx, LLMConfigService_GetLLMConfigsByProvider_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *lLMConfigServiceClient) ListLLMConfigs(ctx context.Context, in *ListLLMConfigsRequest, opts ...grpc.CallOption) (*ListLLMConfigsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListLLMConfigsResponse)
	err := c.cc.Invoke(ctx, LLMConfigService_ListLLMConfigs_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *lLMConfigServiceClient) UpdateLLMConfig(ctx context.Context, in *UpdateLLMConfigRequest, opts ...grpc.CallOption) (*LLMConfig, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(LLMConfig)
	err := c.cc.Invoke(ctx, LLMConfigService_UpdateLLMConfig_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *lLMConfigServiceClient) DeleteLLMConfig(ctx context.Context, in *DeleteLLMConfigRequest, opts ...grpc.CallOption) (*DeleteLLMConfigResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeleteLLMConfigResponse)
	err := c.cc.Invoke(ctx, LLMConfigService_DeleteLLMConfig_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// LLMConfigServiceServer is the server API for LLMConfigService service.
// All implementations must embed UnimplementedLLMConfigServiceServer
// for forward compatibility.
type LLMConfigServiceServer interface {
	CreateLLMConfig(context.Context, *CreateLLMConfigRequest) (*LLMConfig, error)
	GetLLMConfig(context.Context, *GetLLMConfigRequest) (*LLMConfig, error)
	GetDefaultLLMConfig(context.Context, *GetDefaultLLMConfigRequest) (*LLMConfig, error)
	GetLLMConfigsByProvider(context.Context, *GetLLMConfigsByProviderRequest) (*GetLLMConfigsByProviderResponse, error)
	ListLLMConfigs(context.Context, *ListLLMConfigsRequest) (*ListLLMConfigsResponse, error)
	UpdateLLMConfig(context.Context, *UpdateLLMConfigRequest) (*LLMConfig, error)
	DeleteLLMConfig(context.Context, *DeleteLLMConfigRequest) (*DeleteLLMConfigResponse, error)
	mustEmbedUnimplementedLLMConfigServiceServer()
}

// UnimplementedLLMConfigServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedLLMConfigServiceServer struct{}

func (UnimplementedLLMConfigServiceServer) CreateLLMConfig(context.Context, *CreateLLMConfigRequest) (*LLMConfig, error) {
	return nil, status.Error(codes.Unimplemented, "method CreateLLMConfig not implemented")
}
func (UnimplementedLLMConfigServiceServer) GetLLMConfig(context.Context, *GetLLMConfigRequest) (*LLMConfig, error) {
	return nil, status.Error(codes.Unimplemented, "method GetLLMConfig not implemented")
}
func (UnimplementedLLMConfigServiceServer) GetDefaultLLMConfig(context.Context, *GetDefaultLLMConfigRequest) (*LLMConfig, error) {
	return nil, status.Error(codes.Unimplemented, "method GetDefaultLLMConfig not implemented")
}
func (UnimplementedLLMConfigServiceServer) GetLLMConfigsByProvider(context.Context, *GetLLMConfigsByProviderRequest) (*GetLLMConfigsByProviderResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetLLMConfigsByProvider not implemented")
}
func (UnimplementedLLMConfigServiceServer) ListLLMConfigs(context.Context, *ListLLMConfigsRequest) (*ListLLMConfigsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ListLLMConfigs not implemented")
}
func (UnimplementedLLMConfigServiceServer) UpdateLLMConfig(context.Context, *UpdateLLMConfigRequest) (*LLMConfig, error) {
	return nil, status.Error(codes.Unimplemented, "method UpdateLLMConfig not implemented")
}
func (UnimplementedLLMConfigServiceServer) DeleteLLMConfig(context.Context, *DeleteLLMConfigRequest) (*DeleteLLMConfigResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method DeleteLLMConfig not implemented")
}
func (UnimplementedLLMConfigServiceServer) mustEmbedUnimplementedLLMConfigServiceServer() {}
func (UnimplementedLLMConfigServiceServer) testEmbeddedByValue()                          {}

// UnsafeLLMConfigServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to LLMConfigServiceServer will
// result in compilation errors.
type UnsafeLLMConfigServiceServer interface {
	mustEmbedUnimplementedLLMConfigServiceServer()
}

func RegisterLLMConfigServiceServer(s grpc.ServiceRegistrar, srv LLMConfigServiceServer) {
	// If the following call panics, it indicates UnimplementedLLMConfigServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&LLMConfigService_ServiceDesc, srv)
}

func _LLMConfigService_CreateLLMConfig_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateLLMConfigRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LLMConfigServiceServer).CreateLLMConfig(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LLMConfigService_CreateLLMConfig_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LLMConfigServiceServer).CreateLLMConfig(ctx, req.(*CreateLLMConfigRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LLMConfigService_GetLLMConfig_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetLLMConfigRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LLMConfigServiceServer).GetLLMConfig(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LLMConfigService_GetLLMConfig_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LLMConfigServiceServer).GetLLMConfig(ctx, req.(*GetLLMConfigRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LLMConfigService_GetDefaultLLMConfig_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetDefaultLLMConfigRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LLMConfigServiceServer).GetDefaultLLMConfig(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LLMConfigService_GetDefaultLLMConfig_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LLMConfigServiceServer).GetDefaultLLMConfig(ctx, req.(*GetDefaultLLMConfigRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LLMConfigService_GetLLMConfigsByProvider_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetLLMConfigsByProviderRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LLMConfigServiceServer).GetLLMConfigsByProvider(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LLMConfigService_GetLLMConfigsByProvider_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LLMConfigServiceServer).GetLLMConfigsByProvider(ctx, req.(*GetLLMConfigsByProviderRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LLMConfigService_ListLLMConfigs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListLLMConfigsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LLMConfigServiceServer).ListLLMConfigs(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LLMConfigService_ListLLMConfigs_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LLMConfigServiceServer).ListLLMConfigs(ctx, req.(*ListLLMConfigsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LLMConfigService_UpdateLLMConfig_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateLLMConfigRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LLMConfigServiceServer).UpdateLLMConfig(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LLMConfigService_UpdateLLMConfig_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LLMConfigServiceServer).UpdateLLMConfig(ctx, req.(*UpdateLLMConfigRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LLMConfigService_DeleteLLMConfig_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteLLMConfigRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LLMConfigServiceServer).DeleteLLMConfig(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LLMConfigService_DeleteLLMConfig_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LLMConfigServiceServer).DeleteLLMConfig(ctx, req.(*DeleteLLMConfigRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// LLMConfigService_ServiceDesc is the grpc.ServiceDesc for LLMConfigService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var LLMConfigService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "chatee.dbc.LLMConfigService",
	HandlerType: (*LLMConfigServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateLLMConfig",
			Handler:    _LLMConfigService_CreateLLMConfig_Handler,
		},
		{
			MethodName: "GetLLMConfig",
			Handler:    _LLMConfigService_GetLLMConfig_Handler,
		},
		{
			MethodName: "GetDefaultLLMConfig",
			Handler:    _LLMConfigService_GetDefaultLLMConfig_Handler,
		},
		{
			MethodName: "GetLLMConfigsByProvider",
			Handler:    _LLMConfigService_GetLLMConfigsByProvider_Handler,
		},
		{
			MethodName: "ListLLMConfigs",
			Handler:    _LLMConfigService_ListLLMConfigs_Handler,
		},
		{
			MethodName: "UpdateLLMConfig",
			Handler:    _LLMConfigService_UpdateLLMConfig_Handler,
		},
		{
			MethodName: "DeleteLLMConfig",
			Handler:    _LLMConfigService_DeleteLLMConfig_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "dbc/dbc.proto",
}

const (
	MCPServerService_CreateMCPServer_FullMethodName     = "/chatee.dbc.MCPServerService/CreateMCPServer"
	MCPServerService_GetMCPServer_FullMethodName        = "/chatee.dbc.MCPServerService/GetMCPServer"
	MCPServerService_GetMCPServersByUser_FullMethodName = "/chatee.dbc.MCPServerService/GetMCPServersByUser"
	MCPServerService_ListMCPServers_FullMethodName      = "/chatee.dbc.MCPServerService/ListMCPServers"
	MCPServerService_UpdateMCPServer_FullMethodName     = "/chatee.dbc.MCPServerService/UpdateMCPServer"
	MCPServerService_DeleteMCPServer_FullMethodName     = "/chatee.dbc.MCPServerService/DeleteMCPServer"
)

// MCPServerServiceClient is the client API for MCPServerService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type MCPServerServiceClient interface {
	CreateMCPServer(ctx context.Context, in *CreateMCPServerRequest, opts ...grpc.CallOption) (*MCPServer, error)
	GetMCPServer(ctx context.Context, in *GetMCPServerRequest, opts ...grpc.CallOption) (*MCPServer, error)
	GetMCPServersByUser(ctx context.Context, in *GetMCPServersByUserRequest, opts ...grpc.CallOption) (*GetMCPServersByUserResponse, error)
	ListMCPServers(ctx context.Context, in *ListMCPServersRequest, opts ...grpc.CallOption) (*ListMCPServersResponse, error)
	UpdateMCPServer(ctx context.Context, in *UpdateMCPServerRequest, opts ...grpc.CallOption) (*MCPServer, error)
	DeleteMCPServer(ctx context.Context, in *DeleteMCPServerRequest, opts ...grpc.CallOption) (*DeleteMCPServerResponse, error)
}

type mCPServerServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewMCPServerServiceClient(cc grpc.ClientConnInterface) MCPServerServiceClient {
	return &mCPServerServiceClient{cc}
}

func (c *mCPServerServiceClient) CreateMCPServer(ctx context.Context, in *CreateMCPServerRequest, opts ...grpc.CallOption) (*MCPServer, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MCPServer)
	err := c.cc.Invoke(ctx, MCPServerService_CreateMCPServer_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mCPServerServiceClient) GetMCPServer(ctx context.Context, in *GetMCPServerRequest, opts ...grpc.CallOption) (*MCPServer, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MCPServer)
	err := c.cc.Invoke(ctx, MCPServerService_GetMCPServer_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mCPServerServiceClient) GetMCPServersByUser(ctx context.Context, in *GetMCPServersByUserRequest, opts ...grpc.CallOption) (*GetMCPServersByUserResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetMCPServersByUserResponse)
	err := c.cc.Invoke(ctx, MCPServerService_GetMCPServersByUser_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mCPServerServiceClient) ListMCPServers(ctx context.Context, in *ListMCPServersRequest, opts ...grpc.CallOption) (*ListMCPServersResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListMCPServersResponse)
	err := c.cc.Invoke(ctx, MCPServerService_ListMCPServers_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mCPServerServiceClient) UpdateMCPServer(ctx context.Context, in *UpdateMCPServerRequest, opts ...grpc.CallOption) (*MCPServer, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MCPServer)
	err := c.cc.Invoke(ctx, MCPServerService_UpdateMCPServer_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mCPServerServiceClient) DeleteMCPServer(ctx context.Context, in *DeleteMCPServerRequest, opts ...grpc.CallOption) (*DeleteMCPServerResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeleteMCPServerResponse)
	err := c.cc.Invoke(ctx, MCPServerService_DeleteMCPServer_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// MCPServerServiceServer is the server API for MCPServerService service.
// All implementations must embed UnimplementedMCPServerServiceServer
// for forward compatibility.
type MCPServerServiceServer interface {
	CreateMCPServer(context.Context, *CreateMCPServerRequest) (*MCPServer, error)
	GetMCPServer(context.Context, *GetMCPServerRequest) (*MCPServer, error)
	GetMCPServersByUser(context.Context, *GetMCPServersByUserRequest) (*GetMCPServersByUserResponse, error)
	ListMCPServers(context.Context, *ListMCPServersRequest) (*ListMCPServersResponse, error)
	UpdateMCPServer(context.Context, *UpdateMCPServerRequest) (*MCPServer, error)
	DeleteMCPServer(context.Context, *DeleteMCPServerRequest) (*DeleteMCPServerResponse, error)
	mustEmbedUnimplementedMCPServerServiceServer()
}

// UnimplementedMCPServerServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedMCPServerServiceServer struct{}

func (UnimplementedMCPServerServiceServer) CreateMCPServer(context.Context, *CreateMCPServerRequest) (*MCPServer, error) {
	return nil, status.Error(codes.Unimplemented, "method CreateMCPServer not implemented")
}
func (UnimplementedMCPServerServiceServer) GetMCPServer(context.Context, *GetMCPServerRequest) (*MCPServer, error) {
	return nil, status.Error(codes.Unimplemented, "method GetMCPServer not implemented")
}
func (UnimplementedMCPServerServiceServer) GetMCPServersByUser(context.Context, *GetMCPServersByUserRequest) (*GetMCPServersByUserResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetMCPServersByUser not implemented")
}
func (UnimplementedMCPServerServiceServer) ListMCPServers(context.Context, *ListMCPServersRequest) (*ListMCPServersResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ListMCPServers not implemented")
}
func (UnimplementedMCPServerServiceServer) UpdateMCPServer(context.Context, *UpdateMCPServerRequest) (*MCPServer, error) {
	return nil, status.Error(codes.Unimplemented, "method UpdateMCPServer not implemented")
}
func (UnimplementedMCPServerServiceServer) DeleteMCPServer(context.Context, *DeleteMCPServerRequest) (*DeleteMCPServerResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method DeleteMCPServer not implemented")
}
func (UnimplementedMCPServerServiceServer) mustEmbedUnimplementedMCPServerServiceServer() {}
func (UnimplementedMCPServerServiceServer) testEmbeddedByValue()                          {}

// UnsafeMCPServerServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to MCPServerServiceServer will
// result in compilation errors.
type UnsafeMCPServerServiceServer interface {
	mustEmbedUnimplementedMCPServerServiceServer()
}

func RegisterMCPServerServiceServer(s grpc.ServiceRegistrar, srv MCPServerServiceServer) {
	// If the following call panics, it indicates UnimplementedMCPServerServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&MCPServerService_ServiceDesc, srv)
}

func _MCPServerService_CreateMCPServer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateMCPServerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MCPServerServiceServer).CreateMCPServer(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MCPServerService_CreateMCPServer_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MCPServerServiceServer).CreateMCPServer(ctx, req.(*CreateMCPServerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MCPServerService_GetMCPServer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetMCPServerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MCPServerServiceServer).GetMCPServer(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MCPServerService_GetMCPServer_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MCPServerServiceServer).GetMCPServer(ctx, req.(*GetMCPServerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MCPServerService_GetMCPServersByUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetMCPServersByUserRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MCPServerServiceServer).GetMCPServersByUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MCPServerService_GetMCPServersByUser_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MCPServerServiceServer).GetMCPServersByUser(ctx, req.(*GetMCPServersByUserRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MCPServerService_ListMCPServers_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListMCPServersRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MCPServerServiceServer).ListMCPServers(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MCPServerService_ListMCPServers_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MCPServerServiceServer).ListMCPServers(ctx, req.(*ListMCPServersRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MCPServerService_UpdateMCPServer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateMCPServerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MCPServerServiceServer).UpdateMCPServer(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MCPServerService_UpdateMCPServer_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MCPServerServiceServer).UpdateMCPServer(ctx, req.(*UpdateMCPServerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MCPServerService_DeleteMCPServer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteMCPServerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MCPServerServiceServer).DeleteMCPServer(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MCPServerService_DeleteMCPServer_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MCPServerServiceServer).DeleteMCPServer(ctx, req.(*DeleteMCPServerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// MCPServerService_ServiceDesc is the grpc.ServiceDesc for MCPServerService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var MCPServerService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "chatee.dbc.MCPServerService",
	HandlerType: (*MCPServerServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateMCPServer",
			Handler:    _MCPServerService_CreateMCPServer_Handler,
		},
		{
			MethodName: "GetMCPServer",
			Handler:    _MCPServerService_GetMCPServer_Handler,
		},
		{
			MethodName: "GetMCPServersByUser",
			Handler:    _MCPServerService_GetMCPServersByUser_Handler,
		},
		{
			MethodName: "ListMCPServers",
			Handler:    _MCPServerService_ListMCPServers_Handler,
		},
		{
			MethodName: "UpdateMCPServer",
			Handler:    _MCPServerService_UpdateMCPServer_Handler,
		},
		{
			MethodName: "DeleteMCPServer",
			Handler:    _MCPServerService_DeleteMCPServer_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "dbc/dbc.proto",
}

const (
	HBaseThreadService_SaveThreadMetadata_FullMethodName = "/chatee.dbc.HBaseThreadService/SaveThreadMetadata"
	HBaseThreadService_GetThreadMetadata_FullMethodName  = "/chatee.dbc.HBaseThreadService/GetThreadMetadata"
	HBaseThreadService_SaveThreadMessage_FullMethodName  = "/chatee.dbc.HBaseThreadService/SaveThreadMessage"
	HBaseThreadService_GetThreadMessage_FullMethodName   = "/chatee.dbc.HBaseThreadService/GetThreadMessage"
	HBaseThreadService_GetThreadMessages_FullMethodName  = "/chatee.dbc.HBaseThreadService/GetThreadMessages"
	HBaseThreadService_SaveFollowFeed_FullMethodName     = "/chatee.dbc.HBaseThreadService/SaveFollowFeed"
	HBaseThreadService_GetUserFollowFeeds_FullMethodName = "/chatee.dbc.HBaseThreadService/GetUserFollowFeeds"
	HBaseThreadService_SaveReplyFeed_FullMethodName      = "/chatee.dbc.HBaseThreadService/SaveReplyFeed"
	HBaseThreadService_GetUserReplyFeeds_FullMethodName  = "/chatee.dbc.HBaseThreadService/GetUserReplyFeeds"
)

// HBaseThreadServiceClient is the client API for HBaseThreadService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type HBaseThreadServiceClient interface {
	// Thread Metadata
	SaveThreadMetadata(ctx context.Context, in *SaveThreadMetadataRequest, opts ...grpc.CallOption) (*SaveThreadMetadataResponse, error)
	GetThreadMetadata(ctx context.Context, in *GetThreadMetadataRequest, opts ...grpc.CallOption) (*ThreadMetadata, error)
	// Thread Messages
	SaveThreadMessage(ctx context.Context, in *SaveThreadMessageRequest, opts ...grpc.CallOption) (*SaveThreadMessageResponse, error)
	GetThreadMessage(ctx context.Context, in *GetThreadMessageRequest, opts ...grpc.CallOption) (*ThreadMessageRow, error)
	GetThreadMessages(ctx context.Context, in *GetThreadMessagesRequest, opts ...grpc.CallOption) (*GetThreadMessagesResponse, error)
	// Follow Feeds ()
	SaveFollowFeed(ctx context.Context, in *SaveFollowFeedRequest, opts ...grpc.CallOption) (*SaveFollowFeedResponse, error)
	GetUserFollowFeeds(ctx context.Context, in *GetUserFollowFeedsRequest, opts ...grpc.CallOption) (*GetUserFollowFeedsResponse, error)
	// Reply Feeds ()
	SaveReplyFeed(ctx context.Context, in *SaveReplyFeedRequest, opts ...grpc.CallOption) (*SaveReplyFeedResponse, error)
	GetUserReplyFeeds(ctx context.Context, in *GetUserReplyFeedsRequest, opts ...grpc.CallOption) (*GetUserReplyFeedsResponse, error)
}

type hBaseThreadServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewHBaseThreadServiceClient(cc grpc.ClientConnInterface) HBaseThreadServiceClient {
	return &hBaseThreadServiceClient{cc}
}

func (c *hBaseThreadServiceClient) SaveThreadMetadata(ctx context.Context, in *SaveThreadMetadataRequest, opts ...grpc.CallOption) (*SaveThreadMetadataResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SaveThreadMetadataResponse)
	err := c.cc.Invoke(ctx, HBaseThreadService_SaveThreadMetadata_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *hBaseThreadServiceClient) GetThreadMetadata(ctx context.Context, in *GetThreadMetadataRequest, opts ...grpc.CallOption) (*ThreadMetadata, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ThreadMetadata)
	err := c.cc.Invoke(ctx, HBaseThreadService_GetThreadMetadata_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *hBaseThreadServiceClient) SaveThreadMessage(ctx context.Context, in *SaveThreadMessageRequest, opts ...grpc.CallOption) (*SaveThreadMessageResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SaveThreadMessageResponse)
	err := c.cc.Invoke(ctx, HBaseThreadService_SaveThreadMessage_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *hBaseThreadServiceClient) GetThreadMessage(ctx context.Context, in *GetThreadMessageRequest, opts ...grpc.CallOption) (*ThreadMessageRow, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ThreadMessageRow)
	err := c.cc.Invoke(ctx, HBaseThreadService_GetThreadMessage_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *hBaseThreadServiceClient) GetThreadMessages(ctx context.Context, in *GetThreadMessagesRequest, opts ...grpc.CallOption) (*GetThreadMessagesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetThreadMessagesResponse)
	err := c.cc.Invoke(ctx, HBaseThreadService_GetThreadMessages_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *hBaseThreadServiceClient) SaveFollowFeed(ctx context.Context, in *SaveFollowFeedRequest, opts ...grpc.CallOption) (*SaveFollowFeedResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SaveFollowFeedResponse)
	err := c.cc.Invoke(ctx, HBaseThreadService_SaveFollowFeed_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *hBaseThreadServiceClient) GetUserFollowFeeds(ctx context.Context, in *GetUserFollowFeedsRequest, opts ...grpc.CallOption) (*GetUserFollowFeedsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetUserFollowFeedsResponse)
	err := c.cc.Invoke(ctx, HBaseThreadService_GetUserFollowFeeds_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *hBaseThreadServiceClient) SaveReplyFeed(ctx context.Context, in *SaveReplyFeedRequest, opts ...grpc.CallOption) (*SaveReplyFeedResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SaveReplyFeedResponse)
	err := c.cc.Invoke(ctx, HBaseThreadService_SaveReplyFeed_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *hBaseThreadServiceClient) GetUserReplyFeeds(ctx context.Context, in *GetUserReplyFeedsRequest, opts ...grpc.CallOption) (*GetUserReplyFeedsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetUserReplyFeedsResponse)
	err := c.cc.Invoke(ctx, HBaseThreadService_GetUserReplyFeeds_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// HBaseThreadServiceServer is the server API for HBaseThreadService service.
// All implementations must embed UnimplementedHBaseThreadServiceServer
// for forward compatibility.
type HBaseThreadServiceServer interface {
	// Thread Metadata
	SaveThreadMetadata(context.Context, *SaveThreadMetadataRequest) (*SaveThreadMetadataResponse, error)
	GetThreadMetadata(context.Context, *GetThreadMetadataRequest) (*ThreadMetadata, error)
	// Thread Messages
	SaveThreadMessage(context.Context, *SaveThreadMessageRequest) (*SaveThreadMessageResponse, error)
	GetThreadMessage(context.Context, *GetThreadMessageRequest) (*ThreadMessageRow, error)
	GetThreadMessages(context.Context, *GetThreadMessagesRequest) (*GetThreadMessagesResponse, error)
	// Follow Feeds ()
	SaveFollowFeed(context.Context, *SaveFollowFeedRequest) (*SaveFollowFeedResponse, error)
	GetUserFollowFeeds(context.Context, *GetUserFollowFeedsRequest) (*GetUserFollowFeedsResponse, error)
	// Reply Feeds ()
	SaveReplyFeed(context.Context, *SaveReplyFeedRequest) (*SaveReplyFeedResponse, error)
	GetUserReplyFeeds(context.Context, *GetUserReplyFeedsRequest) (*GetUserReplyFeedsResponse, error)
	mustEmbedUnimplementedHBaseThreadServiceServer()
}

// UnimplementedHBaseThreadServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedHBaseThreadServiceServer struct{}

func (UnimplementedHBaseThreadServiceServer) SaveThreadMetadata(context.Context, *SaveThreadMetadataRequest) (*SaveThreadMetadataResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method SaveThreadMetadata not implemented")
}
func (UnimplementedHBaseThreadServiceServer) GetThreadMetadata(context.Context, *GetThreadMetadataRequest) (*ThreadMetadata, error) {
	return nil, status.Error(codes.Unimplemented, "method GetThreadMetadata not implemented")
}
func (UnimplementedHBaseThreadServiceServer) SaveThreadMessage(context.Context, *SaveThreadMessageRequest) (*SaveThreadMessageResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method SaveThreadMessage not implemented")
}
func (UnimplementedHBaseThreadServiceServer) GetThreadMessage(context.Context, *GetThreadMessageRequest) (*ThreadMessageRow, error) {
	return nil, status.Error(codes.Unimplemented, "method GetThreadMessage not implemented")
}
func (UnimplementedHBaseThreadServiceServer) GetThreadMessages(context.Context, *GetThreadMessagesRequest) (*GetThreadMessagesResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetThreadMessages not implemented")
}
func (UnimplementedHBaseThreadServiceServer) SaveFollowFeed(context.Context, *SaveFollowFeedRequest) (*SaveFollowFeedResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method SaveFollowFeed not implemented")
}
func (UnimplementedHBaseThreadServiceServer) GetUserFollowFeeds(context.Context, *GetUserFollowFeedsRequest) (*GetUserFollowFeedsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetUserFollowFeeds not implemented")
}
func (UnimplementedHBaseThreadServiceServer) SaveReplyFeed(context.Context, *SaveReplyFeedRequest) (*SaveReplyFeedResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method SaveReplyFeed not implemented")
}
func (UnimplementedHBaseThreadServiceServer) GetUserReplyFeeds(context.Context, *GetUserReplyFeedsRequest) (*GetUserReplyFeedsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetUserReplyFeeds not implemented")
}
func (UnimplementedHBaseThreadServiceServer) mustEmbedUnimplementedHBaseThreadServiceServer() {}
func (UnimplementedHBaseThreadServiceServer) testEmbeddedByValue()                            {}

// UnsafeHBaseThreadServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to HBaseThreadServiceServer will
// result in compilation errors.
type UnsafeHBaseThreadServiceServer interface {
	mustEmbedUnimplementedHBaseThreadServiceServer()
}

func RegisterHBaseThreadServiceServer(s grpc.ServiceRegistrar, srv HBaseThreadServiceServer) {
	// If the following call panics, it indicates UnimplementedHBaseThreadServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&HBaseThreadService_ServiceDesc, srv)
}

func _HBaseThreadService_SaveThreadMetadata_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SaveThreadMetadataRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HBaseThreadServiceServer).SaveThreadMetadata(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: HBaseThreadService_SaveThreadMetadata_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HBaseThreadServiceServer).SaveThreadMetadata(ctx, req.(*SaveThreadMetadataRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _HBaseThreadService_GetThreadMetadata_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetThreadMetadataRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HBaseThreadServiceServer).GetThreadMetadata(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: HBaseThreadService_GetThreadMetadata_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HBaseThreadServiceServer).GetThreadMetadata(ctx, req.(*GetThreadMetadataRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _HBaseThreadService_SaveThreadMessage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SaveThreadMessageRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HBaseThreadServiceServer).SaveThreadMessage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: HBaseThreadService_SaveThreadMessage_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HBaseThreadServiceServer).SaveThreadMessage(ctx, req.(*SaveThreadMessageRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _HBaseThreadService_GetThreadMessage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetThreadMessageRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HBaseThreadServiceServer).GetThreadMessage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: HBaseThreadService_GetThreadMessage_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HBaseThreadServiceServer).GetThreadMessage(ctx, req.(*GetThreadMessageRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _HBaseThreadService_GetThreadMessages_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetThreadMessagesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HBaseThreadServiceServer).GetThreadMessages(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: HBaseThreadService_GetThreadMessages_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HBaseThreadServiceServer).GetThreadMessages(ctx, req.(*GetThreadMessagesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _HBaseThreadService_SaveFollowFeed_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SaveFollowFeedRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HBaseThreadServiceServer).SaveFollowFeed(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: HBaseThreadService_SaveFollowFeed_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HBaseThreadServiceServer).SaveFollowFeed(ctx, req.(*SaveFollowFeedRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _HBaseThreadService_GetUserFollowFeeds_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetUserFollowFeedsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HBaseThreadServiceServer).GetUserFollowFeeds(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: HBaseThreadService_GetUserFollowFeeds_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HBaseThreadServiceServer).GetUserFollowFeeds(ctx, req.(*GetUserFollowFeedsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _HBaseThreadService_SaveReplyFeed_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SaveReplyFeedRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HBaseThreadServiceServer).SaveReplyFeed(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: HBaseThreadService_SaveReplyFeed_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HBaseThreadServiceServer).SaveReplyFeed(ctx, req.(*SaveReplyFeedRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _HBaseThreadService_GetUserReplyFeeds_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetUserReplyFeedsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HBaseThreadServiceServer).GetUserReplyFeeds(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: HBaseThreadService_GetUserReplyFeeds_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HBaseThreadServiceServer).GetUserReplyFeeds(ctx, req.(*GetUserReplyFeedsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// HBaseThreadService_ServiceDesc is the grpc.ServiceDesc for HBaseThreadService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var HBaseThreadService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "chatee.dbc.HBaseThreadService",
	HandlerType: (*HBaseThreadServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "SaveThreadMetadata",
			Handler:    _HBaseThreadService_SaveThreadMetadata_Handler,
		},
		{
			MethodName: "GetThreadMetadata",
			Handler:    _HBaseThreadService_GetThreadMetadata_Handler,
		},
		{
			MethodName: "SaveThreadMessage",
			Handler:    _HBaseThreadService_SaveThreadMessage_Handler,
		},
		{
			MethodName: "GetThreadMessage",
			Handler:    _HBaseThreadService_GetThreadMessage_Handler,
		},
		{
			MethodName: "GetThreadMessages",
			Handler:    _HBaseThreadService_GetThreadMessages_Handler,
		},
		{
			MethodName: "SaveFollowFeed",
			Handler:    _HBaseThreadService_SaveFollowFeed_Handler,
		},
		{
			MethodName: "GetUserFollowFeeds",
			Handler:    _HBaseThreadService_GetUserFollowFeeds_Handler,
		},
		{
			MethodName: "SaveReplyFeed",
			Handler:    _HBaseThreadService_SaveReplyFeed_Handler,
		},
		{
			MethodName: "GetUserReplyFeeds",
			Handler:    _HBaseThreadService_GetUserReplyFeeds_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "dbc/dbc.proto",
}

const (
	HBaseChatService_SaveChatMetadata_FullMethodName = "/chatee.dbc.HBaseChatService/SaveChatMetadata"
	HBaseChatService_GetChatMetadata_FullMethodName  = "/chatee.dbc.HBaseChatService/GetChatMetadata"
	HBaseChatService_SaveChatInbox_FullMethodName    = "/chatee.dbc.HBaseChatService/SaveChatInbox"
	HBaseChatService_GetUserChatInbox_FullMethodName = "/chatee.dbc.HBaseChatService/GetUserChatInbox"
)

// HBaseChatServiceClient is the client API for HBaseChatService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type HBaseChatServiceClient interface {
	// Chat Metadata
	SaveChatMetadata(ctx context.Context, in *SaveChatMetadataRequest, opts ...grpc.CallOption) (*SaveChatMetadataResponse, error)
	GetChatMetadata(ctx context.Context, in *GetChatMetadataRequest, opts ...grpc.CallOption) (*ChatMetadataRow, error)
	// Chat Inbox ()
	SaveChatInbox(ctx context.Context, in *SaveChatInboxRequest, opts ...grpc.CallOption) (*SaveChatInboxResponse, error)
	GetUserChatInbox(ctx context.Context, in *GetUserChatInboxRequest, opts ...grpc.CallOption) (*GetUserChatInboxResponse, error)
}

type hBaseChatServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewHBaseChatServiceClient(cc grpc.ClientConnInterface) HBaseChatServiceClient {
	return &hBaseChatServiceClient{cc}
}

func (c *hBaseChatServiceClient) SaveChatMetadata(ctx context.Context, in *SaveChatMetadataRequest, opts ...grpc.CallOption) (*SaveChatMetadataResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SaveChatMetadataResponse)
	err := c.cc.Invoke(ctx, HBaseChatService_SaveChatMetadata_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *hBaseChatServiceClient) GetChatMetadata(ctx context.Context, in *GetChatMetadataRequest, opts ...grpc.CallOption) (*ChatMetadataRow, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ChatMetadataRow)
	err := c.cc.Invoke(ctx, HBaseChatService_GetChatMetadata_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *hBaseChatServiceClient) SaveChatInbox(ctx context.Context, in *SaveChatInboxRequest, opts ...grpc.CallOption) (*SaveChatInboxResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SaveChatInboxResponse)
	err := c.cc.Invoke(ctx, HBaseChatService_SaveChatInbox_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *hBaseChatServiceClient) GetUserChatInbox(ctx context.Context, in *GetUserChatInboxRequest, opts ...grpc.CallOption) (*GetUserChatInboxResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetUserChatInboxResponse)
	err := c.cc.Invoke(ctx, HBaseChatService_GetUserChatInbox_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// HBaseChatServiceServer is the server API for HBaseChatService service.
// All implementations must embed UnimplementedHBaseChatServiceServer
// for forward compatibility.
type HBaseChatServiceServer interface {
	// Chat Metadata
	SaveChatMetadata(context.Context, *SaveChatMetadataRequest) (*SaveChatMetadataResponse, error)
	GetChatMetadata(context.Context, *GetChatMetadataRequest) (*ChatMetadataRow, error)
	// Chat Inbox ()
	SaveChatInbox(context.Context, *SaveChatInboxRequest) (*SaveChatInboxResponse, error)
	GetUserChatInbox(context.Context, *GetUserChatInboxRequest) (*GetUserChatInboxResponse, error)
	mustEmbedUnimplementedHBaseChatServiceServer()
}

// UnimplementedHBaseChatServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedHBaseChatServiceServer struct{}

func (UnimplementedHBaseChatServiceServer) SaveChatMetadata(context.Context, *SaveChatMetadataRequest) (*SaveChatMetadataResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method SaveChatMetadata not implemented")
}
func (UnimplementedHBaseChatServiceServer) GetChatMetadata(context.Context, *GetChatMetadataRequest) (*ChatMetadataRow, error) {
	return nil, status.Error(codes.Unimplemented, "method GetChatMetadata not implemented")
}
func (UnimplementedHBaseChatServiceServer) SaveChatInbox(context.Context, *SaveChatInboxRequest) (*SaveChatInboxResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method SaveChatInbox not implemented")
}
func (UnimplementedHBaseChatServiceServer) GetUserChatInbox(context.Context, *GetUserChatInboxRequest) (*GetUserChatInboxResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetUserChatInbox not implemented")
}
func (UnimplementedHBaseChatServiceServer) mustEmbedUnimplementedHBaseChatServiceServer() {}
func (UnimplementedHBaseChatServiceServer) testEmbeddedByValue()                          {}

// UnsafeHBaseChatServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to HBaseChatServiceServer will
// result in compilation errors.
type UnsafeHBaseChatServiceServer interface {
	mustEmbedUnimplementedHBaseChatServiceServer()
}

func RegisterHBaseChatServiceServer(s grpc.ServiceRegistrar, srv HBaseChatServiceServer) {
	// If the following call panics, it indicates UnimplementedHBaseChatServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&HBaseChatService_ServiceDesc, srv)
}

func _HBaseChatService_SaveChatMetadata_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SaveChatMetadataRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HBaseChatServiceServer).SaveChatMetadata(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: HBaseChatService_SaveChatMetadata_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HBaseChatServiceServer).SaveChatMetadata(ctx, req.(*SaveChatMetadataRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _HBaseChatService_GetChatMetadata_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetChatMetadataRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HBaseChatServiceServer).GetChatMetadata(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: HBaseChatService_GetChatMetadata_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HBaseChatServiceServer).GetChatMetadata(ctx, req.(*GetChatMetadataRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _HBaseChatService_SaveChatInbox_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SaveChatInboxRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HBaseChatServiceServer).SaveChatInbox(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: HBaseChatService_SaveChatInbox_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HBaseChatServiceServer).SaveChatInbox(ctx, req.(*SaveChatInboxRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _HBaseChatService_GetUserChatInbox_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetUserChatInboxRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HBaseChatServiceServer).GetUserChatInbox(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: HBaseChatService_GetUserChatInbox_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HBaseChatServiceServer).GetUserChatInbox(ctx, req.(*GetUserChatInboxRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// HBaseChatService_ServiceDesc is the grpc.ServiceDesc for HBaseChatService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var HBaseChatService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "chatee.dbc.HBaseChatService",
	HandlerType: (*HBaseChatServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "SaveChatMetadata",
			Handler:    _HBaseChatService_SaveChatMetadata_Handler,
		},
		{
			MethodName: "GetChatMetadata",
			Handler:    _HBaseChatService_GetChatMetadata_Handler,
		},
		{
			MethodName: "SaveChatInbox",
			Handler:    _HBaseChatService_SaveChatInbox_Handler,
		},
		{
			MethodName: "GetUserChatInbox",
			Handler:    _HBaseChatService_GetUserChatInbox_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "dbc/dbc.proto",
}

const (
	CacheService_Get_FullMethodName       = "/chatee.dbc.CacheService/Get"
	CacheService_Set_FullMethodName       = "/chatee.dbc.CacheService/Set"
	CacheService_Delete_FullMethodName    = "/chatee.dbc.CacheService/Delete"
	CacheService_Exists_FullMethodName    = "/chatee.dbc.CacheService/Exists"
	CacheService_Expire_FullMethodName    = "/chatee.dbc.CacheService/Expire"
	CacheService_SAdd_FullMethodName      = "/chatee.dbc.CacheService/SAdd"
	CacheService_SRem_FullMethodName      = "/chatee.dbc.CacheService/SRem"
	CacheService_SMembers_FullMethodName  = "/chatee.dbc.CacheService/SMembers"
	CacheService_SIsMember_FullMethodName = "/chatee.dbc.CacheService/SIsMember"
	CacheService_SCard_FullMethodName     = "/chatee.dbc.CacheService/SCard"
	CacheService_ZAdd_FullMethodName      = "/chatee.dbc.CacheService/ZAdd"
	CacheService_ZRem_FullMethodName      = "/chatee.dbc.CacheService/ZRem"
	CacheService_ZRange_FullMethodName    = "/chatee.dbc.CacheService/ZRange"
	CacheService_ZRevRange_FullMethodName = "/chatee.dbc.CacheService/ZRevRange"
	CacheService_ZScore_FullMethodName    = "/chatee.dbc.CacheService/ZScore"
	CacheService_ZIncrBy_FullMethodName   = "/chatee.dbc.CacheService/ZIncrBy"
	CacheService_HGet_FullMethodName      = "/chatee.dbc.CacheService/HGet"
	CacheService_HSet_FullMethodName      = "/chatee.dbc.CacheService/HSet"
	CacheService_HGetAll_FullMethodName   = "/chatee.dbc.CacheService/HGetAll"
	CacheService_HIncrBy_FullMethodName   = "/chatee.dbc.CacheService/HIncrBy"
	CacheService_HDel_FullMethodName      = "/chatee.dbc.CacheService/HDel"
	CacheService_Incr_FullMethodName      = "/chatee.dbc.CacheService/Incr"
	CacheService_Decr_FullMethodName      = "/chatee.dbc.CacheService/Decr"
	CacheService_IncrBy_FullMethodName    = "/chatee.dbc.CacheService/IncrBy"
	CacheService_DecrBy_FullMethodName    = "/chatee.dbc.CacheService/DecrBy"
	CacheService_Publish_FullMethodName   = "/chatee.dbc.CacheService/Publish"
	CacheService_MGet_FullMethodName      = "/chatee.dbc.CacheService/MGet"
	CacheService_MSet_FullMethodName      = "/chatee.dbc.CacheService/MSet"
)

// CacheServiceClient is the client API for CacheService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type CacheServiceClient interface {
	// String operations
	Get(ctx context.Context, in *GetRequest, opts ...grpc.CallOption) (*GetResponse, error)
	Set(ctx context.Context, in *SetRequest, opts ...grpc.CallOption) (*SetResponse, error)
	Delete(ctx context.Context, in *DeleteRequest, opts ...grpc.CallOption) (*DeleteResponse, error)
	Exists(ctx context.Context, in *ExistsRequest, opts ...grpc.CallOption) (*ExistsResponse, error)
	Expire(ctx context.Context, in *ExpireRequest, opts ...grpc.CallOption) (*ExpireResponse, error)
	// Set operations (for user relationships)
	SAdd(ctx context.Context, in *SAddRequest, opts ...grpc.CallOption) (*SAddResponse, error)
	SRem(ctx context.Context, in *SRemRequest, opts ...grpc.CallOption) (*SRemResponse, error)
	SMembers(ctx context.Context, in *SMembersRequest, opts ...grpc.CallOption) (*SMembersResponse, error)
	SIsMember(ctx context.Context, in *SIsMemberRequest, opts ...grpc.CallOption) (*SIsMemberResponse, error)
	SCard(ctx context.Context, in *SCardRequest, opts ...grpc.CallOption) (*SCardResponse, error)
	// Sorted Set operations (for timelines, rankings)
	ZAdd(ctx context.Context, in *ZAddRequest, opts ...grpc.CallOption) (*ZAddResponse, error)
	ZRem(ctx context.Context, in *ZRemRequest, opts ...grpc.CallOption) (*ZRemResponse, error)
	ZRange(ctx context.Context, in *ZRangeRequest, opts ...grpc.CallOption) (*ZRangeResponse, error)
	ZRevRange(ctx context.Context, in *ZRevRangeRequest, opts ...grpc.CallOption) (*ZRevRangeResponse, error)
	ZScore(ctx context.Context, in *ZScoreRequest, opts ...grpc.CallOption) (*ZScoreResponse, error)
	ZIncrBy(ctx context.Context, in *ZIncrByRequest, opts ...grpc.CallOption) (*ZIncrByResponse, error)
	// Hash operations
	HGet(ctx context.Context, in *HGetRequest, opts ...grpc.CallOption) (*HGetResponse, error)
	HSet(ctx context.Context, in *HSetRequest, opts ...grpc.CallOption) (*HSetResponse, error)
	HGetAll(ctx context.Context, in *HGetAllRequest, opts ...grpc.CallOption) (*HGetAllResponse, error)
	HIncrBy(ctx context.Context, in *HIncrByRequest, opts ...grpc.CallOption) (*HIncrByResponse, error)
	HDel(ctx context.Context, in *HDelRequest, opts ...grpc.CallOption) (*HDelResponse, error)
	// Counter operations
	Incr(ctx context.Context, in *IncrRequest, opts ...grpc.CallOption) (*IncrResponse, error)
	Decr(ctx context.Context, in *DecrRequest, opts ...grpc.CallOption) (*DecrResponse, error)
	IncrBy(ctx context.Context, in *IncrByRequest, opts ...grpc.CallOption) (*IncrByResponse, error)
	DecrBy(ctx context.Context, in *DecrByRequest, opts ...grpc.CallOption) (*DecrByResponse, error)
	// Pub/Sub operations
	Publish(ctx context.Context, in *PublishRequest, opts ...grpc.CallOption) (*PublishResponse, error)
	// Batch operations
	MGet(ctx context.Context, in *MGetRequest, opts ...grpc.CallOption) (*MGetResponse, error)
	MSet(ctx context.Context, in *MSetRequest, opts ...grpc.CallOption) (*MSetResponse, error)
}

type cacheServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewCacheServiceClient(cc grpc.ClientConnInterface) CacheServiceClient {
	return &cacheServiceClient{cc}
}

func (c *cacheServiceClient) Get(ctx context.Context, in *GetRequest, opts ...grpc.CallOption) (*GetResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetResponse)
	err := c.cc.Invoke(ctx, CacheService_Get_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cacheServiceClient) Set(ctx context.Context, in *SetRequest, opts ...grpc.CallOption) (*SetResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SetResponse)
	err := c.cc.Invoke(ctx, CacheService_Set_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cacheServiceClient) Delete(ctx context.Context, in *DeleteRequest, opts ...grpc.CallOption) (*DeleteResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeleteResponse)
	err := c.cc.Invoke(ctx, CacheService_Delete_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cacheServiceClient) Exists(ctx context.Context, in *ExistsRequest, opts ...grpc.CallOption) (*ExistsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ExistsResponse)
	err := c.cc.Invoke(ctx, CacheService_Exists_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cacheServiceClient) Expire(ctx context.Context, in *ExpireRequest, opts ...grpc.CallOption) (*ExpireResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ExpireResponse)
	err := c.cc.Invoke(ctx, CacheService_Expire_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cacheServiceClient) SAdd(ctx context.Context, in *SAddRequest, opts ...grpc.CallOption) (*SAddResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SAddResponse)
	err := c.cc.Invoke(ctx, CacheService_SAdd_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cacheServiceClient) SRem(ctx context.Context, in *SRemRequest, opts ...grpc.CallOption) (*SRemResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SRemResponse)
	err := c.cc.Invoke(ctx, CacheService_SRem_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cacheServiceClient) SMembers(ctx context.Context, in *SMembersRequest, opts ...grpc.CallOption) (*SMembersResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SMembersResponse)
	err := c.cc.Invoke(ctx, CacheService_SMembers_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cacheServiceClient) SIsMember(ctx context.Context, in *SIsMemberRequest, opts ...grpc.CallOption) (*SIsMemberResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SIsMemberResponse)
	err := c.cc.Invoke(ctx, CacheService_SIsMember_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cacheServiceClient) SCard(ctx context.Context, in *SCardRequest, opts ...grpc.CallOption) (*SCardResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SCardResponse)
	err := c.cc.Invoke(ctx, CacheService_SCard_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cacheServiceClient) ZAdd(ctx context.Context, in *ZAddRequest, opts ...grpc.CallOption) (*ZAddResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ZAddResponse)
	err := c.cc.Invoke(ctx, CacheService_ZAdd_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cacheServiceClient) ZRem(ctx context.Context, in *ZRemRequest, opts ...grpc.CallOption) (*ZRemResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ZRemResponse)
	err := c.cc.Invoke(ctx, CacheService_ZRem_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cacheServiceClient) ZRange(ctx context.Context, in *ZRangeRequest, opts ...grpc.CallOption) (*ZRangeResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ZRangeResponse)
	err := c.cc.Invoke(ctx, CacheService_ZRange_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cacheServiceClient) ZRevRange(ctx context.Context, in *ZRevRangeRequest, opts ...grpc.CallOption) (*ZRevRangeResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ZRevRangeResponse)
	err := c.cc.Invoke(ctx, CacheService_ZRevRange_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cacheServiceClient) ZScore(ctx context.Context, in *ZScoreRequest, opts ...grpc.CallOption) (*ZScoreResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ZScoreResponse)
	err := c.cc.Invoke(ctx, CacheService_ZScore_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cacheServiceClient) ZIncrBy(ctx context.Context, in *ZIncrByRequest, opts ...grpc.CallOption) (*ZIncrByResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ZIncrByResponse)
	err := c.cc.Invoke(ctx, CacheService_ZIncrBy_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cacheServiceClient) HGet(ctx context.Context, in *HGetRequest, opts ...grpc.CallOption) (*HGetResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(HGetResponse)
	err := c.cc.Invoke(ctx, CacheService_HGet_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cacheServiceClient) HSet(ctx context.Context, in *HSetRequest, opts ...grpc.CallOption) (*HSetResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(HSetResponse)
	err := c.cc.Invoke(ctx, CacheService_HSet_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cacheServiceClient) HGetAll(ctx context.Context, in *HGetAllRequest, opts ...grpc.CallOption) (*HGetAllResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(HGetAllResponse)
	err := c.cc.Invoke(ctx, CacheService_HGetAll_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cacheServiceClient) HIncrBy(ctx context.Context, in *HIncrByRequest, opts ...grpc.CallOption) (*HIncrByResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(HIncrByResponse)
	err := c.cc.Invoke(ctx, CacheService_HIncrBy_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cacheServiceClient) HDel(ctx context.Context, in *HDelRequest, opts ...grpc.CallOption) (*HDelResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(HDelResponse)
	err := c.cc.Invoke(ctx, CacheService_HDel_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cacheServiceClient) Incr(ctx context.Context, in *IncrRequest, opts ...grpc.CallOption) (*IncrResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(IncrResponse)
	err := c.cc.Invoke(ctx, CacheService_Incr_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cacheServiceClient) Decr(ctx context.Context, in *DecrRequest, opts ...grpc.CallOption) (*DecrResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DecrResponse)
	err := c.cc.Invoke(ctx, CacheService_Decr_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cacheServiceClient) IncrBy(ctx context.Context, in *IncrByRequest, opts ...grpc.CallOption) (*IncrByResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(IncrByResponse)
	err := c.cc.Invoke(ctx, CacheService_IncrBy_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cacheServiceClient) DecrBy(ctx context.Context, in *DecrByRequest, opts ...grpc.CallOption) (*DecrByResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DecrByResponse)
	err := c.cc.Invoke(ctx, CacheService_DecrBy_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cacheServiceClient) Publish(ctx context.Context, in *PublishRequest, opts ...grpc.CallOption) (*PublishResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(PublishResponse)
	err := c.cc.Invoke(ctx, CacheService_Publish_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cacheServiceClient) MGet(ctx context.Context, in *MGetRequest, opts ...grpc.CallOption) (*MGetResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MGetResponse)
	err := c.cc.Invoke(ctx, CacheService_MGet_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cacheServiceClient) MSet(ctx context.Context, in *MSetRequest, opts ...grpc.CallOption) (*MSetResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MSetResponse)
	err := c.cc.Invoke(ctx, CacheService_MSet_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// CacheServiceServer is the server API for CacheService service.
// All implementations must embed UnimplementedCacheServiceServer
// for forward compatibility.
type CacheServiceServer interface {
	// String operations
	Get(context.Context, *GetRequest) (*GetResponse, error)
	Set(context.Context, *SetRequest) (*SetResponse, error)
	Delete(context.Context, *DeleteRequest) (*DeleteResponse, error)
	Exists(context.Context, *ExistsRequest) (*ExistsResponse, error)
	Expire(context.Context, *ExpireRequest) (*ExpireResponse, error)
	// Set operations (for user relationships)
	SAdd(context.Context, *SAddRequest) (*SAddResponse, error)
	SRem(context.Context, *SRemRequest) (*SRemResponse, error)
	SMembers(context.Context, *SMembersRequest) (*SMembersResponse, error)
	SIsMember(context.Context, *SIsMemberRequest) (*SIsMemberResponse, error)
	SCard(context.Context, *SCardRequest) (*SCardResponse, error)
	// Sorted Set operations (for timelines, rankings)
	ZAdd(context.Context, *ZAddRequest) (*ZAddResponse, error)
	ZRem(context.Context, *ZRemRequest) (*ZRemResponse, error)
	ZRange(context.Context, *ZRangeRequest) (*ZRangeResponse, error)
	ZRevRange(context.Context, *ZRevRangeRequest) (*ZRevRangeResponse, error)
	ZScore(context.Context, *ZScoreRequest) (*ZScoreResponse, error)
	ZIncrBy(context.Context, *ZIncrByRequest) (*ZIncrByResponse, error)
	// Hash operations
	HGet(context.Context, *HGetRequest) (*HGetResponse, error)
	HSet(context.Context, *HSetRequest) (*HSetResponse, error)
	HGetAll(context.Context, *HGetAllRequest) (*HGetAllResponse, error)
	HIncrBy(context.Context, *HIncrByRequest) (*HIncrByResponse, error)
	HDel(context.Context, *HDelRequest) (*HDelResponse, error)
	// Counter operations
	Incr(context.Context, *IncrRequest) (*IncrResponse, error)
	Decr(context.Context, *DecrRequest) (*DecrResponse, error)
	IncrBy(context.Context, *IncrByRequest) (*IncrByResponse, error)
	DecrBy(context.Context, *DecrByRequest) (*DecrByResponse, error)
	// Pub/Sub operations
	Publish(context.Context, *PublishRequest) (*PublishResponse, error)
	// Batch operations
	MGet(context.Context, *MGetRequest) (*MGetResponse, error)
	MSet(context.Context, *MSetRequest) (*MSetResponse, error)
	mustEmbedUnimplementedCacheServiceServer()
}

// UnimplementedCacheServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedCacheServiceServer struct{}

func (UnimplementedCacheServiceServer) Get(context.Context, *GetRequest) (*GetResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method Get not implemented")
}
func (UnimplementedCacheServiceServer) Set(context.Context, *SetRequest) (*SetResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method Set not implemented")
}
func (UnimplementedCacheServiceServer) Delete(context.Context, *DeleteRequest) (*DeleteResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method Delete not implemented")
}
func (UnimplementedCacheServiceServer) Exists(context.Context, *ExistsRequest) (*ExistsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method Exists not implemented")
}
func (UnimplementedCacheServiceServer) Expire(context.Context, *ExpireRequest) (*ExpireResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method Expire not implemented")
}
func (UnimplementedCacheServiceServer) SAdd(context.Context, *SAddRequest) (*SAddResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method SAdd not implemented")
}
func (UnimplementedCacheServiceServer) SRem(context.Context, *SRemRequest) (*SRemResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method SRem not implemented")
}
func (UnimplementedCacheServiceServer) SMembers(context.Context, *SMembersRequest) (*SMembersResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method SMembers not implemented")
}
func (UnimplementedCacheServiceServer) SIsMember(context.Context, *SIsMemberRequest) (*SIsMemberResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method SIsMember not implemented")
}
func (UnimplementedCacheServiceServer) SCard(context.Context, *SCardRequest) (*SCardResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method SCard not implemented")
}
func (UnimplementedCacheServiceServer) ZAdd(context.Context, *ZAddRequest) (*ZAddResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ZAdd not implemented")
}
func (UnimplementedCacheServiceServer) ZRem(context.Context, *ZRemRequest) (*ZRemResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ZRem not implemented")
}
func (UnimplementedCacheServiceServer) ZRange(context.Context, *ZRangeRequest) (*ZRangeResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ZRange not implemented")
}
func (UnimplementedCacheServiceServer) ZRevRange(context.Context, *ZRevRangeRequest) (*ZRevRangeResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ZRevRange not implemented")
}
func (UnimplementedCacheServiceServer) ZScore(context.Context, *ZScoreRequest) (*ZScoreResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ZScore not implemented")
}
func (UnimplementedCacheServiceServer) ZIncrBy(context.Context, *ZIncrByRequest) (*ZIncrByResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ZIncrBy not implemented")
}
func (UnimplementedCacheServiceServer) HGet(context.Context, *HGetRequest) (*HGetResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method HGet not implemented")
}
func (UnimplementedCacheServiceServer) HSet(context.Context, *HSetRequest) (*HSetResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method HSet not implemented")
}
func (UnimplementedCacheServiceServer) HGetAll(context.Context, *HGetAllRequest) (*HGetAllResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method HGetAll not implemented")
}
func (UnimplementedCacheServiceServer) HIncrBy(context.Context, *HIncrByRequest) (*HIncrByResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method HIncrBy not implemented")
}
func (UnimplementedCacheServiceServer) HDel(context.Context, *HDelRequest) (*HDelResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method HDel not implemented")
}
func (UnimplementedCacheServiceServer) Incr(context.Context, *IncrRequest) (*IncrResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method Incr not implemented")
}
func (UnimplementedCacheServiceServer) Decr(context.Context, *DecrRequest) (*DecrResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method Decr not implemented")
}
func (UnimplementedCacheServiceServer) IncrBy(context.Context, *IncrByRequest) (*IncrByResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method IncrBy not implemented")
}
func (UnimplementedCacheServiceServer) DecrBy(context.Context, *DecrByRequest) (*DecrByResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method DecrBy not implemented")
}
func (UnimplementedCacheServiceServer) Publish(context.Context, *PublishRequest) (*PublishResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method Publish not implemented")
}
func (UnimplementedCacheServiceServer) MGet(context.Context, *MGetRequest) (*MGetResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method MGet not implemented")
}
func (UnimplementedCacheServiceServer) MSet(context.Context, *MSetRequest) (*MSetResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method MSet not implemented")
}
func (UnimplementedCacheServiceServer) mustEmbedUnimplementedCacheServiceServer() {}
func (UnimplementedCacheServiceServer) testEmbeddedByValue()                      {}

// UnsafeCacheServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to CacheServiceServer will
// result in compilation errors.
type UnsafeCacheServiceServer interface {
	mustEmbedUnimplementedCacheServiceServer()
}

func RegisterCacheServiceServer(s grpc.ServiceRegistrar, srv CacheServiceServer) {
	// If the following call panics, it indicates UnimplementedCacheServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&CacheService_ServiceDesc, srv)
}

func _CacheService_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CacheServiceServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CacheService_Get_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CacheServiceServer).Get(ctx, req.(*GetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CacheService_Set_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CacheServiceServer).Set(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CacheService_Set_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CacheServiceServer).Set(ctx, req.(*SetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CacheService_Delete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CacheServiceServer).Delete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CacheService_Delete_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CacheServiceServer).Delete(ctx, req.(*DeleteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CacheService_Exists_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ExistsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CacheServiceServer).Exists(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CacheService_Exists_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CacheServiceServer).Exists(ctx, req.(*ExistsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CacheService_Expire_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ExpireRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CacheServiceServer).Expire(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CacheService_Expire_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CacheServiceServer).Expire(ctx, req.(*ExpireRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CacheService_SAdd_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SAddRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CacheServiceServer).SAdd(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CacheService_SAdd_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CacheServiceServer).SAdd(ctx, req.(*SAddRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CacheService_SRem_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SRemRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CacheServiceServer).SRem(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CacheService_SRem_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CacheServiceServer).SRem(ctx, req.(*SRemRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CacheService_SMembers_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SMembersRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CacheServiceServer).SMembers(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CacheService_SMembers_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CacheServiceServer).SMembers(ctx, req.(*SMembersRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CacheService_SIsMember_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SIsMemberRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CacheServiceServer).SIsMember(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CacheService_SIsMember_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CacheServiceServer).SIsMember(ctx, req.(*SIsMemberRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CacheService_SCard_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SCardRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CacheServiceServer).SCard(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CacheService_SCard_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CacheServiceServer).SCard(ctx, req.(*SCardRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CacheService_ZAdd_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ZAddRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CacheServiceServer).ZAdd(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CacheService_ZAdd_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CacheServiceServer).ZAdd(ctx, req.(*ZAddRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CacheService_ZRem_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ZRemRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CacheServiceServer).ZRem(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CacheService_ZRem_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CacheServiceServer).ZRem(ctx, req.(*ZRemRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CacheService_ZRange_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ZRangeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CacheServiceServer).ZRange(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CacheService_ZRange_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CacheServiceServer).ZRange(ctx, req.(*ZRangeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CacheService_ZRevRange_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ZRevRangeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CacheServiceServer).ZRevRange(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CacheService_ZRevRange_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CacheServiceServer).ZRevRange(ctx, req.(*ZRevRangeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CacheService_ZScore_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ZScoreRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CacheServiceServer).ZScore(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CacheService_ZScore_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CacheServiceServer).ZScore(ctx, req.(*ZScoreRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CacheService_ZIncrBy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ZIncrByRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CacheServiceServer).ZIncrBy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CacheService_ZIncrBy_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CacheServiceServer).ZIncrBy(ctx, req.(*ZIncrByRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CacheService_HGet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HGetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CacheServiceServer).HGet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CacheService_HGet_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CacheServiceServer).HGet(ctx, req.(*HGetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CacheService_HSet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HSetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CacheServiceServer).HSet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CacheService_HSet_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CacheServiceServer).HSet(ctx, req.(*HSetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CacheService_HGetAll_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HGetAllRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CacheServiceServer).HGetAll(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CacheService_HGetAll_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CacheServiceServer).HGetAll(ctx, req.(*HGetAllRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CacheService_HIncrBy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HIncrByRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CacheServiceServer).HIncrBy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CacheService_HIncrBy_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CacheServiceServer).HIncrBy(ctx, req.(*HIncrByRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CacheService_HDel_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HDelRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CacheServiceServer).HDel(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CacheService_HDel_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CacheServiceServer).HDel(ctx, req.(*HDelRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CacheService_Incr_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IncrRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CacheServiceServer).Incr(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CacheService_Incr_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CacheServiceServer).Incr(ctx, req.(*IncrRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CacheService_Decr_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DecrRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CacheServiceServer).Decr(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CacheService_Decr_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CacheServiceServer).Decr(ctx, req.(*DecrRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CacheService_IncrBy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IncrByRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CacheServiceServer).IncrBy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CacheService_IncrBy_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CacheServiceServer).IncrBy(ctx, req.(*IncrByRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CacheService_DecrBy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DecrByRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CacheServiceServer).DecrBy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CacheService_DecrBy_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CacheServiceServer).DecrBy(ctx, req.(*DecrByRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CacheService_Publish_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PublishRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CacheServiceServer).Publish(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CacheService_Publish_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CacheServiceServer).Publish(ctx, req.(*PublishRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CacheService_MGet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MGetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CacheServiceServer).MGet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CacheService_MGet_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CacheServiceServer).MGet(ctx, req.(*MGetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CacheService_MSet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MSetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CacheServiceServer).MSet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CacheService_MSet_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CacheServiceServer).MSet(ctx, req.(*MSetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// CacheService_ServiceDesc is the grpc.ServiceDesc for CacheService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var CacheService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "chatee.dbc.CacheService",
	HandlerType: (*CacheServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Get",
			Handler:    _CacheService_Get_Handler,
		},
		{
			MethodName: "Set",
			Handler:    _CacheService_Set_Handler,
		},
		{
			MethodName: "Delete",
			Handler:    _CacheService_Delete_Handler,
		},
		{
			MethodName: "Exists",
			Handler:    _CacheService_Exists_Handler,
		},
		{
			MethodName: "Expire",
			Handler:    _CacheService_Expire_Handler,
		},
		{
			MethodName: "SAdd",
			Handler:    _CacheService_SAdd_Handler,
		},
		{
			MethodName: "SRem",
			Handler:    _CacheService_SRem_Handler,
		},
		{
			MethodName: "SMembers",
			Handler:    _CacheService_SMembers_Handler,
		},
		{
			MethodName: "SIsMember",
			Handler:    _CacheService_SIsMember_Handler,
		},
		{
			MethodName: "SCard",
			Handler:    _CacheService_SCard_Handler,
		},
		{
			MethodName: "ZAdd",
			Handler:    _CacheService_ZAdd_Handler,
		},
		{
			MethodName: "ZRem",
			Handler:    _CacheService_ZRem_Handler,
		},
		{
			MethodName: "ZRange",
			Handler:    _CacheService_ZRange_Handler,
		},
		{
			MethodName: "ZRevRange",
			Handler:    _CacheService_ZRevRange_Handler,
		},
		{
			MethodName: "ZScore",
			Handler:    _CacheService_ZScore_Handler,
		},
		{
			MethodName: "ZIncrBy",
			Handler:    _CacheService_ZIncrBy_Handler,
		},
		{
			MethodName: "HGet",
			Handler:    _CacheService_HGet_Handler,
		},
		{
			MethodName: "HSet",
			Handler:    _CacheService_HSet_Handler,
		},
		{
			MethodName: "HGetAll",
			Handler:    _CacheService_HGetAll_Handler,
		},
		{
			MethodName: "HIncrBy",
			Handler:    _CacheService_HIncrBy_Handler,
		},
		{
			MethodName: "HDel",
			Handler:    _CacheService_HDel_Handler,
		},
		{
			MethodName: "Incr",
			Handler:    _CacheService_Incr_Handler,
		},
		{
			MethodName: "Decr",
			Handler:    _CacheService_Decr_Handler,
		},
		{
			MethodName: "IncrBy",
			Handler:    _CacheService_IncrBy_Handler,
		},
		{
			MethodName: "DecrBy",
			Handler:    _CacheService_DecrBy_Handler,
		},
		{
			MethodName: "Publish",
			Handler:    _CacheService_Publish_Handler,
		},
		{
			MethodName: "MGet",
			Handler:    _CacheService_MGet_Handler,
		},
		{
			MethodName: "MSet",
			Handler:    _CacheService_MSet_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "dbc/dbc.proto",
}

const (
	ChromaService_CreateCollection_FullMethodName = "/chatee.dbc.ChromaService/CreateCollection"
	ChromaService_GetCollection_FullMethodName    = "/chatee.dbc.ChromaService/GetCollection"
	ChromaService_ListCollections_FullMethodName  = "/chatee.dbc.ChromaService/ListCollections"
	ChromaService_DeleteCollection_FullMethodName = "/chatee.dbc.ChromaService/DeleteCollection"
	ChromaService_AddDocuments_FullMethodName     = "/chatee.dbc.ChromaService/AddDocuments"
	ChromaService_GetDocuments_FullMethodName     = "/chatee.dbc.ChromaService/GetDocuments"
	ChromaService_DeleteDocuments_FullMethodName  = "/chatee.dbc.ChromaService/DeleteDocuments"
	ChromaService_UpdateDocuments_FullMethodName  = "/chatee.dbc.ChromaService/UpdateDocuments"
	ChromaService_Query_FullMethodName            = "/chatee.dbc.ChromaService/Query"
	ChromaService_QueryByIDs_FullMethodName       = "/chatee.dbc.ChromaService/QueryByIDs"
	ChromaService_GetEmbeddings_FullMethodName    = "/chatee.dbc.ChromaService/GetEmbeddings"
)

// ChromaServiceClient is the client API for ChromaService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ChromaServiceClient interface {
	// Collection Management
	CreateCollection(ctx context.Context, in *CreateCollectionRequest, opts ...grpc.CallOption) (*CreateCollectionResponse, error)
	GetCollection(ctx context.Context, in *GetCollectionRequest, opts ...grpc.CallOption) (*Collection, error)
	ListCollections(ctx context.Context, in *ListCollectionsRequest, opts ...grpc.CallOption) (*ListCollectionsResponse, error)
	DeleteCollection(ctx context.Context, in *DeleteCollectionRequest, opts ...grpc.CallOption) (*DeleteCollectionResponse, error)
	// Document Operations
	AddDocuments(ctx context.Context, in *AddDocumentsRequest, opts ...grpc.CallOption) (*AddDocumentsResponse, error)
	GetDocuments(ctx context.Context, in *GetDocumentsRequest, opts ...grpc.CallOption) (*GetDocumentsResponse, error)
	DeleteDocuments(ctx context.Context, in *DeleteDocumentsRequest, opts ...grpc.CallOption) (*DeleteDocumentsResponse, error)
	UpdateDocuments(ctx context.Context, in *UpdateDocumentsRequest, opts ...grpc.CallOption) (*UpdateDocumentsResponse, error)
	// Query Operations (RAG)
	Query(ctx context.Context, in *QueryRequest, opts ...grpc.CallOption) (*QueryResponse, error)
	QueryByIDs(ctx context.Context, in *QueryByIDsRequest, opts ...grpc.CallOption) (*QueryByIDsResponse, error)
	// Embedding Operations
	GetEmbeddings(ctx context.Context, in *GetEmbeddingsRequest, opts ...grpc.CallOption) (*GetEmbeddingsResponse, error)
}

type chromaServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewChromaServiceClient(cc grpc.ClientConnInterface) ChromaServiceClient {
	return &chromaServiceClient{cc}
}

func (c *chromaServiceClient) CreateCollection(ctx context.Context, in *CreateCollectionRequest, opts ...grpc.CallOption) (*CreateCollectionResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CreateCollectionResponse)
	err := c.cc.Invoke(ctx, ChromaService_CreateCollection_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *chromaServiceClient) GetCollection(ctx context.Context, in *GetCollectionRequest, opts ...grpc.CallOption) (*Collection, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Collection)
	err := c.cc.Invoke(ctx, ChromaService_GetCollection_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *chromaServiceClient) ListCollections(ctx context.Context, in *ListCollectionsRequest, opts ...grpc.CallOption) (*ListCollectionsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListCollectionsResponse)
	err := c.cc.Invoke(ctx, ChromaService_ListCollections_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *chromaServiceClient) DeleteCollection(ctx context.Context, in *DeleteCollectionRequest, opts ...grpc.CallOption) (*DeleteCollectionResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeleteCollectionResponse)
	err := c.cc.Invoke(ctx, ChromaService_DeleteCollection_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *chromaServiceClient) AddDocuments(ctx context.Context, in *AddDocumentsRequest, opts ...grpc.CallOption) (*AddDocumentsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(AddDocumentsResponse)
	err := c.cc.Invoke(ctx, ChromaService_AddDocuments_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *chromaServiceClient) GetDocuments(ctx context.Context, in *GetDocumentsRequest, opts ...grpc.CallOption) (*GetDocumentsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetDocumentsResponse)
	err := c.cc.Invoke(ctx, ChromaService_GetDocuments_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *chromaServiceClient) DeleteDocuments(ctx context.Context, in *DeleteDocumentsRequest, opts ...grpc.CallOption) (*DeleteDocumentsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeleteDocumentsResponse)
	err := c.cc.Invoke(ctx, ChromaService_DeleteDocuments_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *chromaServiceClient) UpdateDocuments(ctx context.Context, in *UpdateDocumentsRequest, opts ...grpc.CallOption) (*UpdateDocumentsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UpdateDocumentsResponse)
	err := c.cc.Invoke(ctx, ChromaService_UpdateDocuments_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *chromaServiceClient) Query(ctx context.Context, in *QueryRequest, opts ...grpc.CallOption) (*QueryResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(QueryResponse)
	err := c.cc.Invoke(ctx, ChromaService_Query_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *chromaServiceClient) QueryByIDs(ctx context.Context, in *QueryByIDsRequest, opts ...grpc.CallOption) (*QueryByIDsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(QueryByIDsResponse)
	err := c.cc.Invoke(ctx, ChromaService_QueryByIDs_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *chromaServiceClient) GetEmbeddings(ctx context.Context, in *GetEmbeddingsRequest, opts ...grpc.CallOption) (*GetEmbeddingsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetEmbeddingsResponse)
	err := c.cc.Invoke(ctx, ChromaService_GetEmbeddings_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ChromaServiceServer is the server API for ChromaService service.
// All implementations must embed UnimplementedChromaServiceServer
// for forward compatibility.
type ChromaServiceServer interface {
	// Collection Management
	CreateCollection(context.Context, *CreateCollectionRequest) (*CreateCollectionResponse, error)
	GetCollection(context.Context, *GetCollectionRequest) (*Collection, error)
	ListCollections(context.Context, *ListCollectionsRequest) (*ListCollectionsResponse, error)
	DeleteCollection(context.Context, *DeleteCollectionRequest) (*DeleteCollectionResponse, error)
	// Document Operations
	AddDocuments(context.Context, *AddDocumentsRequest) (*AddDocumentsResponse, error)
	GetDocuments(context.Context, *GetDocumentsRequest) (*GetDocumentsResponse, error)
	DeleteDocuments(context.Context, *DeleteDocumentsRequest) (*DeleteDocumentsResponse, error)
	UpdateDocuments(context.Context, *UpdateDocumentsRequest) (*UpdateDocumentsResponse, error)
	// Query Operations (RAG)
	Query(context.Context, *QueryRequest) (*QueryResponse, error)
	QueryByIDs(context.Context, *QueryByIDsRequest) (*QueryByIDsResponse, error)
	// Embedding Operations
	GetEmbeddings(context.Context, *GetEmbeddingsRequest) (*GetEmbeddingsResponse, error)
	mustEmbedUnimplementedChromaServiceServer()
}

// UnimplementedChromaServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedChromaServiceServer struct{}

func (UnimplementedChromaServiceServer) CreateCollection(context.Context, *CreateCollectionRequest) (*CreateCollectionResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method CreateCollection not implemented")
}
func (UnimplementedChromaServiceServer) GetCollection(context.Context, *GetCollectionRequest) (*Collection, error) {
	return nil, status.Error(codes.Unimplemented, "method GetCollection not implemented")
}
func (UnimplementedChromaServiceServer) ListCollections(context.Context, *ListCollectionsRequest) (*ListCollectionsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ListCollections not implemented")
}
func (UnimplementedChromaServiceServer) DeleteCollection(context.Context, *DeleteCollectionRequest) (*DeleteCollectionResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method DeleteCollection not implemented")
}
func (UnimplementedChromaServiceServer) AddDocuments(context.Context, *AddDocumentsRequest) (*AddDocumentsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method AddDocuments not implemented")
}
func (UnimplementedChromaServiceServer) GetDocuments(context.Context, *GetDocumentsRequest) (*GetDocumentsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetDocuments not implemented")
}
func (UnimplementedChromaServiceServer) DeleteDocuments(context.Context, *DeleteDocumentsRequest) (*DeleteDocumentsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method DeleteDocuments not implemented")
}
func (UnimplementedChromaServiceServer) UpdateDocuments(context.Context, *UpdateDocumentsRequest) (*UpdateDocumentsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method UpdateDocuments not implemented")
}
func (UnimplementedChromaServiceServer) Query(context.Context, *QueryRequest) (*QueryResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method Query not implemented")
}
func (UnimplementedChromaServiceServer) QueryByIDs(context.Context, *QueryByIDsRequest) (*QueryByIDsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method QueryByIDs not implemented")
}
func (UnimplementedChromaServiceServer) GetEmbeddings(context.Context, *GetEmbeddingsRequest) (*GetEmbeddingsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetEmbeddings not implemented")
}
func (UnimplementedChromaServiceServer) mustEmbedUnimplementedChromaServiceServer() {}
func (UnimplementedChromaServiceServer) testEmbeddedByValue()                       {}

// UnsafeChromaServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ChromaServiceServer will
// result in compilation errors.
type UnsafeChromaServiceServer interface {
	mustEmbedUnimplementedChromaServiceServer()
}

func RegisterChromaServiceServer(s grpc.ServiceRegistrar, srv ChromaServiceServer) {
	// If the following call panics, it indicates UnimplementedChromaServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&ChromaService_ServiceDesc, srv)
}

func _ChromaService_CreateCollection_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateCollectionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ChromaServiceServer).CreateCollection(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ChromaService_CreateCollection_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ChromaServiceServer).CreateCollection(ctx, req.(*CreateCollectionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ChromaService_GetCollection_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetCollectionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ChromaServiceServer).GetCollection(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ChromaService_GetCollection_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ChromaServiceServer).GetCollection(ctx, req.(*GetCollectionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ChromaService_ListCollections_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListCollectionsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ChromaServiceServer).ListCollections(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ChromaService_ListCollections_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ChromaServiceServer).ListCollections(ctx, req.(*ListCollectionsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ChromaService_DeleteCollection_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteCollectionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ChromaServiceServer).DeleteCollection(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ChromaService_DeleteCollection_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ChromaServiceServer).DeleteCollection(ctx, req.(*DeleteCollectionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ChromaService_AddDocuments_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddDocumentsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ChromaServiceServer).AddDocuments(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ChromaService_AddDocuments_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ChromaServiceServer).AddDocuments(ctx, req.(*AddDocumentsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ChromaService_GetDocuments_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetDocumentsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ChromaServiceServer).GetDocuments(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ChromaService_GetDocuments_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ChromaServiceServer).GetDocuments(ctx, req.(*GetDocumentsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ChromaService_DeleteDocuments_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteDocumentsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ChromaServiceServer).DeleteDocuments(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ChromaService_DeleteDocuments_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ChromaServiceServer).DeleteDocuments(ctx, req.(*DeleteDocumentsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ChromaService_UpdateDocuments_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateDocumentsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ChromaServiceServer).UpdateDocuments(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ChromaService_UpdateDocuments_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ChromaServiceServer).UpdateDocuments(ctx, req.(*UpdateDocumentsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ChromaService_Query_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ChromaServiceServer).Query(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ChromaService_Query_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ChromaServiceServer).Query(ctx, req.(*QueryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ChromaService_QueryByIDs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryByIDsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ChromaServiceServer).QueryByIDs(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ChromaService_QueryByIDs_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ChromaServiceServer).QueryByIDs(ctx, req.(*QueryByIDsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ChromaService_GetEmbeddings_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetEmbeddingsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ChromaServiceServer).GetEmbeddings(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ChromaService_GetEmbeddings_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ChromaServiceServer).GetEmbeddings(ctx, req.(*GetEmbeddingsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// ChromaService_ServiceDesc is the grpc.ServiceDesc for ChromaService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ChromaService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "chatee.dbc.ChromaService",
	HandlerType: (*ChromaServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateCollection",
			Handler:    _ChromaService_CreateCollection_Handler,
		},
		{
			MethodName: "GetCollection",
			Handler:    _ChromaService_GetCollection_Handler,
		},
		{
			MethodName: "ListCollections",
			Handler:    _ChromaService_ListCollections_Handler,
		},
		{
			MethodName: "DeleteCollection",
			Handler:    _ChromaService_DeleteCollection_Handler,
		},
		{
			MethodName: "AddDocuments",
			Handler:    _ChromaService_AddDocuments_Handler,
		},
		{
			MethodName: "GetDocuments",
			Handler:    _ChromaService_GetDocuments_Handler,
		},
		{
			MethodName: "DeleteDocuments",
			Handler:    _ChromaService_DeleteDocuments_Handler,
		},
		{
			MethodName: "UpdateDocuments",
			Handler:    _ChromaService_UpdateDocuments_Handler,
		},
		{
			MethodName: "Query",
			Handler:    _ChromaService_Query_Handler,
		},
		{
			MethodName: "QueryByIDs",
			Handler:    _ChromaService_QueryByIDs_Handler,
		},
		{
			MethodName: "GetEmbeddings",
			Handler:    _ChromaService_GetEmbeddings_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "dbc/dbc.proto",
}
